---
title: "Gestures for Positioning, Scaling, and Rotating Virtual Globes"
author: "Faisal Agung Abdillah"
date: "2025-05-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Gestures for Globes Research

# Data and Libraries Load
```{r}
library(tidyverse)
library(dplyr)
library(car)
library(ggplot2)
library(lubridate)
library(scales)
library(ARTool)
library(knitr)

data <- read_csv("study_tasks.csv")
demographic <- read_csv("final_introductory.csv")
positioning_NRG <- read_csv("final_positioning_NRG.csv")
positioning_RG <- read_csv("final_positioning_RG.csv")
positioning_preference <- read_csv("final_positioning_comparison.csv")
rotation_OH <- read_csv("final_rotation_OH.csv")
rotation_TH <- read_csv("final_rotation_TH.csv")
rotation_preference <- read_csv("final_rotation_comparison.csv")
scale_MG <- read_csv("final_scale_MG.csv")
scale_NMG <- read_csv("final_scale_NMG.csv")
scale_preference <- read_csv("final_scale_comparison.csv")
combined_preference <- read_csv("final_outro_comparison.csv")

summary(data)

summary(demographic)

summary(positioning_NRG)

summary(positioning_RG)

summary(positioning_preference)

summary(rotation_OH)

summary(rotation_TH)

summary(rotation_preference)

summary(scale_MG)

summary(scale_NMG)

summary(scale_preference)

summary(combined_preference)
```

# Participants Demographic Information

```{r Demographic}
# Total number of participants
length(unique(data$UserID))

# Participants' gender distribution
demographic.gender <-  demographic %>%
  select(UserID, Gender) %>%
  distinct() %>%
  group_by(Gender) %>%
  summarise(count = n()) %>%
  mutate(percentage = round(count / sum(count) * 100, 1), percentage = paste0(percentage, "%"))

demographic.gender

# Participants' gender distribution chart
ggplot(demographic.gender, aes(x = "", y = count, fill = Gender)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = percentage), position = position_stack(vjust = 0.5), size = 4) +
  labs(title = "Distribution of Participants' Gender") +
  theme_void()

# Participants' academic level distribution
demographic.academic_level <-  demographic %>%
  select(UserID, Academic_level) %>%
  distinct() %>%
  group_by(Academic_level) %>%
  summarise(count = n()) %>%
  mutate(percentage = round(count / sum(count) * 100, 1), graph_label = paste0(percentage, "%")) %>%
  rename(`Academic levels` = Academic_level)

demographic.academic_level

# Participants' academic level distribution chart
ggplot(demographic.academic_level, aes(x = "", y = count, fill = `Academic levels`)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = graph_label), position = position_stack(vjust = 0.5), size = 4) +
  labs(title = "Distribution of Participants' Academic Level") +
  theme_void() 

# Participants' previous AR/VR experience distribution
demographic.ARVR_exp <-  demographic %>%
  select(UserID, Exp_ARVR ) %>%
  distinct() %>%
  group_by(Exp_ARVR) %>%
  summarise(count = n()) %>%
  mutate(percentage = round(count / sum(count) * 100, 1), 
         label = paste0(percentage, "%"),
         ShortLabel = fct_recode(Exp_ARVR,
                          "No experience" = "I have no experience")
) %>%
  rename(`Previous AR/VR experience` = ShortLabel)

demographic.ARVR_exp

# Participants' previous AR/VR experience distribution chart
ggplot(demographic.ARVR_exp, aes(x = "", y = count, fill = `Previous AR/VR experience`)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = label), position = position_stack(vjust = 0.5), size = 4) +
  labs(title = "Distribution of Participants Previous AR/VR Experience") +
  theme_void() 

# Participants' previous globe experience distribution
demographic.globes_exp <- demographic %>%
  select(UserID, Globe_usage_frequency) %>%
  distinct() %>%
  group_by(Globe_usage_frequency) %>%
  summarise(count = n()) %>%
  mutate(percentage = round(count / sum(count) * 100, 1),
         graph_label = paste0(percentage, "%")) %>%
  rename(`Previous globes experience` = Globe_usage_frequency)

demographic.globes_exp

# Participants' previous globe experience distribution chart
ggplot(demographic.globes_exp, aes(x = "", y = count, fill = `Previous globes experience`)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = graph_label), position = position_stack(vjust = 0.5), size = 4) +
  labs(title = "Distribution of Participants Previous AR/VR Experience") +
  theme_void() 

# Participants' previous Apple Vision Pro Experience distribution
demographic.visionpro_exp <- demographic %>%
  select(UserID, Have_used_VisionPro) %>%
  distinct() %>%
  group_by(Have_used_VisionPro) %>%
  summarise(count = n()) %>%
  mutate(
    percentage = round(count / sum(count) * 100, 1),
    graph_label = paste0(percentage, "%")
  ) %>%
  rename(`Have used Apple Vision Pro` = Have_used_VisionPro)
  
demographic.visionpro_exp
  
# Participants' previous Apple Vision Pro Experience distribution chart
ggplot(demographic.visionpro_exp, aes(x = "", y = count, fill = `Have used Apple Vision Pro`)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = graph_label), position = position_stack(vjust = 0.5), size = 4) +
  labs(title = "Distribution of Participants Previous AR/VR Experience") +
  theme_void()   

```


Notes:
Use boxplot instead of bar chart
Add technique column

Structure it like this:

## Study: Positioning
### Positioning Data Preparation
```{r Positioning Data Preparation}
data.positioning <- data %>%
  inner_join(demographic, by = "UserID") %>%
  inner_join(positioning_NRG, by = "UserID") %>%
  rename(
    PAAS_NRG = Mentally_demanding,
    BORG_NRG = Physically_demanding
  ) %>%
  mutate(
    PAAS_NRG = as.numeric(str_extract(PAAS_NRG, "\\d+(\\.\\d+)?")),
    BORG_NRG = as.numeric(str_extract(BORG_NRG, "\\d+(\\.\\d+)?"))
  ) %>%
  inner_join(positioning_RG, by = "UserID") %>%
  rename(
    PAAS_RG = Mentally_demanding,
    BORG_RG = Physically_demanding
  ) %>%
  mutate(
    PAAS_RG = as.numeric(str_extract(PAAS_RG, "\\d+(\\.\\d+)?")),
    BORG_RG = as.numeric(str_extract(BORG_RG, "\\d+(\\.\\d+)?"))
  ) %>%
  inner_join(positioning_preference, by = "UserID") %>%
  rename(
    behaviour_preference = Positioning_preference,
    behaviour_feedback = Positioning_feedback
  ) %>%
  mutate(
      behaviour_preference = case_when(
    str_detect(behaviour_preference, "Static orientation") ~ "staticOrientation",
    str_detect(behaviour_preference, "Adaptive orientation") ~ "adaptiveOrientation",
    str_detect(behaviour_preference, "no preference") ~ "noPreference",
    TRUE ~ "unknown"
  ) ) %>%
  filter(Type == "positionTask") %>%
  select(UserID, TaskID, ActionID, rotateGlobeWhileDragging, distance, direction, Date, ActionStatus, main_translation_x,
  main_translation_y, main_translation_z, target_translation_x, target_translation_y, target_translation_z, 
  match_accuracy_result, status, PAAS_NRG, BORG_NRG, PAAS_RG, BORG_RG, behaviour_preference, behaviour_feedback) %>%
  mutate(positionCondition = if_else(rotateGlobeWhileDragging, "rotatingGlobe", "nonRotatingGlobe")) %>%
  select(-rotateGlobeWhileDragging) %>%
  mutate(distance = as.factor(distance), 
         direction = as.factor(direction), 
         positionCondition = as.factor(positionCondition),
         status = as.factor(status),
         behaviour_preference = as.factor(behaviour_preference))


```

### Position Task Study
```{r PositionStudy}
### Accuracy
#### Normality
data.positioning.matched <- data.positioning %>%
  filter(status == "Matched")

shapiro.test(data.positioning.matched$match_accuracy_result)

hist(data.positioning.matched$match_accuracy_result, breaks = 100,
     main = "Histogram (Zoomed)", xlab = "Accuracy",
     col = "lightblue", xlim = c(0, 0.06))

plot(density(data.positioning.matched$match_accuracy_result), 
     main = "Density Plot (Zoomed)", xlab = "Accuracy",
     col = "blue", lwd = 2, xlim = c(0, 0.6))

# Although the w value is close to 1, the p value is below 0.05 so we reject null hypothesis that the data is normally distributed
# So, we cannot use one way ANOVA, instead, we use Wilcoxon signed-rank test

#### Statistical tests 
data.positioning.matched.accuracy_avg.long <- data.positioning.matched %>%
  group_by(UserID, positionCondition) %>%
  summarise(mean_accuracy = mean(match_accuracy_result, na.rm = TRUE), .groups = 'drop')

data.positioning.matched.art <- art(mean_accuracy ~ positionCondition + (1|UserID), data = data.positioning.matched.accuracy_avg.long)

anova(data.positioning.matched.art)

# Factor tested: positionCondition (e.g., rotatingGlobe vs nonRotatingGlobe)
# F-statistic: 0.33588 — this tells us the ratio of variance between the groups to the variance within groups (after aligned rank transformation).
# Degrees of freedom (df): 1 for the factor, and 11 for the residuals (which likely means 12 participants).
# p-value: 0.5739 — this is not statistically significant at any common threshold (e.g., 0.05).

# An ART ANOVA revealed no significant effect of position condition (rotating vs non-rotating) on match accuracy, F(1, 11) = 0.34, p = .574.

ggplot(data.positioning.matched.accuracy_avg.long, aes(x = positionCondition, y = mean_accuracy, group = UserID)) +
  geom_line(aes(color = as.factor(UserID))) +
  geom_point(size = 3) +
  labs(title = "Paired Accuracy: Moving vs Non-Moving Globe",
       x = "Condition",
       y = "Match Accuracy") +
  theme_minimal()

ggplot(data.positioning.matched.accuracy_avg.long, aes(x = positionCondition, y = mean_accuracy)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  labs(title = "Accuracy by Globe Movement Condition",
       x = "Condition",
       y = "Match Accuracy") +
  theme_minimal()

### Completion Time
data.positioning.taskCompletion_avg <- data.positioning %>%
  group_by(UserID, TaskID) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  )

shapiro.test(data.positioning.taskCompletion_avg$completion_time)

data.positioning.taskCompletion_avg.long <- data.positioning %>%
  group_by(UserID, positionCondition, TaskID) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  group_by(UserID, positionCondition) %>%
  summarise(
    avg_completion_time = mean(completion_time),
    .groups = "drop"
  ) 
  # %>%
  # pivot_wider(names_from = positionCondition, values_from = avg_completion_time)

# wilcox.test(
#   data.positioning.taskCompletion_avg.wide$rotatingGlobe,
#   data.positioning.taskCompletion_avg.wide$nonRotatingGlobe,
#   paired = TRUE,
#   alternative = "two.sided"
# )

data.positioning.taskCompletion_avg.art <- art(avg_completion_time ~ positionCondition + (1|UserID), data = data.positioning.taskCompletion_avg.long)

anova(data.positioning.taskCompletion_avg.art)

# The test statistic is F(1, 11) = 0.264, with a p-value of 0.618.
# Since p > 0.05, the result is not statistically significant.
# This means that there is no evidence of a significant effect of positionCondition on avg_completion_time.
# 
# An aligned rank transform ANOVA showed that position condition did not significantly affect average task completion time, F(1, 11) = 0.26, p = .618.

# data.positioning.taskCompletion_avg.long <- data.positioning.taskCompletion_avg.wide %>%
#   pivot_longer(cols = c(rotatingGlobe, nonRotatingGlobe),
#                names_to = "Condition",
#                values_to = "completion_time")

ggplot(data.positioning.taskCompletion_avg.long, aes(x = positionCondition, y = avg_completion_time, group = UserID)) +
  geom_line(aes(color = as.factor(UserID)), linewidth = 1, alpha = 0.6) +
  geom_point(size = 3) +
  labs(
    title = "Task Completion Time by Condition",
    x = "Condition",
    y = "Completion Time (minutes)",
    color = "UserID"
  ) +
  theme_minimal()

ggplot(data.positioning.taskCompletion_avg.long, aes(x = positionCondition, y = avg_completion_time)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  labs(title = "Accuracy by Globe Movement Condition",
       x = "Condition",
       y = "Match Accuracy") +
  theme_minimal()

### Subjective Measures
#### Physical and Mental Exertion

# Spearman’s rank correlation is a non-parametric test.
# It does not assume normal distribution of the variables.
# It works on ranks of the data, not the raw values — so it’s robust against skewed or non-normal distributions.

data.positioning.matched.RG <- data.positioning.matched %>% 
  filter(positionCondition == "rotatingGlobe")

cor.test(data.positioning.matched.RG$BORG_RG, 
         data.positioning.matched.RG$match_accuracy_result, method = "spearman")

ggplot(data.positioning.matched.RG, aes(x = BORG_RG, y = match_accuracy_result)) +
  geom_point(color = "steelblue", size = 2, alpha = 0.7) +
  geom_smooth(method = "loess", color = "darkred", se = TRUE) +
  labs(
    title = "Correlation between Physical Exertion and Accuracy (Rotating Globe)",
    x = "Physical Exertion (BORG_RG)",
    y = "Match Accuracy Result"
  ) +
  theme_minimal()

data.positioning.matched.NRG <- data.positioning.matched %>% 
  filter(positionCondition == "nonRotatingGlobe")

cor.test(data.positioning.matched.NRG$BORG_NRG, 
         data.positioning.matched.NRG$match_accuracy_result, method = "spearman")

ggplot(data.positioning.matched.NRG, aes(x = BORG_NRG, y = match_accuracy_result)) +
  geom_point(color = "steelblue", size = 2, alpha = 0.7) +
  geom_smooth(method = "loess", color = "darkred", se = TRUE) +
  labs(
    title = "Correlation between Physical Exertion and Accuracy (Non-rotating Globe)",
    x = "Physical Exertion (BORG_NRG)",
    y = "Match Accuracy Result"
  ) +
  theme_minimal()

data.positioning.taskCompletion_avg.RG <- data.positioning %>%
  group_by(UserID, positionCondition, PAAS_RG, BORG_RG, TaskID) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  filter(positionCondition == "rotatingGlobe")

cor.test(data.positioning.taskCompletion_avg.RG$BORG_RG, 
         data.positioning.taskCompletion_avg.RG$completion_time, method = "spearman")

data.positioning.taskCompletion_avg.NRG <- data.positioning %>%
  group_by(UserID, positionCondition, PAAS_NRG, BORG_NRG, TaskID) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  filter(positionCondition == "nonRotatingGlobe")

cor.test(data.positioning.taskCompletion_avg.NRG$BORG_NRG, 
         data.positioning.taskCompletion_avg.NRG$completion_time, method = "spearman")

# PAAS vs Accuracy
data.positioning.matched.RG$condition <- "RG"
data.positioning.matched.NRG$condition <- "NRG"

data.positioning.matched.PAAS_combined <- bind_rows(
  data.positioning.matched.RG %>% rename(PAAS = PAAS_RG),
  data.positioning.matched.NRG %>% rename(PAAS = PAAS_NRG)
)

ggplot(data.positioning.matched.PAAS_combined, aes(x = PAAS, y = match_accuracy_result, color = condition)) +
  geom_point(alpha = 0.7) +
  geom_smooth(method = "lm", se = TRUE) +
  labs(
    title = "Mental Exertion vs Match Accuracy in Positioning",
    x = "PAAS Scale",
    y = "Match Accuracy",
    color = "Condition"
  ) +
  scale_color_manual(values = c("RG" = "blue", "NRG" = "red")) +
  theme_minimal()

# PAAS vs Completion Time

data.positioning.taskCompletion_avg.RG$condition <- "RG"
data.positioning.taskCompletion_avg.NRG$condition <- "NRG"

data.positioning.taskCompletion_avg.PAAS_combined <- bind_rows(
  data.positioning.taskCompletion_avg.RG %>% 
    rename(PAAS = PAAS_RG),
  data.positioning.taskCompletion_avg.NRG %>% 
    rename(PAAS = PAAS_NRG)
)

ggplot(data.positioning.taskCompletion_avg.PAAS_combined, aes(x = PAAS, y = completion_time, color = condition)) +
  geom_point(alpha = 0.7) +
  geom_smooth(method = "lm", se = TRUE) +
  labs(
    title = "Mental Exertion vs Completion Time in Positioning",
    x = "PASS Scale",
    y = "Completion Time",
    color = "Condition"
  ) +
  scale_color_manual(values = c("RG" = "blue", "NRG" = "red")) +
  theme_minimal()

# BORG vs Accuracy
data.positioning.matched.RG$condition <- "RG"
data.positioning.matched.NRG$condition <- "NRG"

data.positioning.matched.BORG_combined <- bind_rows(
  data.positioning.matched.RG %>% rename(BORG = BORG_RG),
  data.positioning.matched.NRG %>% rename(BORG = BORG_NRG)
)

ggplot(data.positioning.matched.BORG_combined, aes(x = BORG, y = match_accuracy_result, color = condition)) +
  geom_point(alpha = 0.7) +
  geom_smooth(method = "lm", se = TRUE) +
  labs(
    title = "Physical Exertion vs Match Accuracy in Positioning",
    x = "BORG Scale",
    y = "Match Accuracy",
    color = "Condition"
  ) +
  scale_color_manual(values = c("RG" = "blue", "NRG" = "red")) +
  theme_minimal()

# BORG vs Completion Time

data.positioning.taskCompletion_avg.RG$condition <- "RG"
data.positioning.taskCompletion_avg.NRG$condition <- "NRG"

data.positioning.taskCompletion_avg.BORG_combined <- bind_rows(
  data.positioning.taskCompletion_avg.RG %>% 
    rename(BORG = BORG_RG),
  data.positioning.taskCompletion_avg.NRG %>% 
    rename(BORG = BORG_NRG)
)

ggplot(data.positioning.taskCompletion_avg.BORG_combined, aes(x = BORG, y = completion_time, color = condition)) +
  geom_point(alpha = 0.7) +
  geom_smooth(method = "lm", se = TRUE) +
  labs(
    title = "Physical Exertion vs Completion Time  in Positioning",
    x = "BORG Scale",
    y = "Completion Time",
    color = "Condition"
  ) +
  scale_color_manual(values = c("RG" = "blue", "NRG" = "red")) +
  theme_minimal()

#### Preference
data.positioning %>%
  select(UserID, behaviour_preference) %>%
  distinct() %>%  
  count(behaviour_preference) %>%
  mutate(
    percent = n / sum(n),
    ncount = paste0(n, "\n", percent_format()(percent))
  ) %>%
  ggplot(aes(x = "", y = n, fill = behaviour_preference)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = ncount), position = position_stack(vjust = 0.5), size = 4) +
  labs(
    title = "Distribution of Positioning Behaviour Preferences",
    fill = "Preference"
  ) +
  theme_void()
#### Comments

data.positioning.preference.summary <- data.positioning %>%
  mutate(
    behaviour_preference = case_when(
      behaviour_preference == "staticOrientation" ~ "Static Orientation",
      behaviour_preference == "adaptiveOrientation" ~ "Adaptive Orientation",
      behaviour_preference == "noPreference" ~ "No Preference",
      TRUE ~ behaviour_preference
    )
  ) %>%
  group_by(UserID) %>%
  summarise(
    behaviour_preference = first(behaviour_preference),
    behaviour_feedback = first(behaviour_feedback),
    .groups = "drop"
  )

kable(data.positioning.preference.summary, caption = "User Feedback Summary - Positioning")

### Summary
```

## Study: Rotating
### Rotating Data Preparation
```{r Rotating Data Preparation}
data.rotating <- data %>%
  inner_join(demographic, by = "UserID") %>%
  inner_join(rotation_OH, by = "UserID") %>%
  rename(
    PAAS_OH = Mentally_demanding,
    BORG_OH = Physically_demanding
  ) %>%
  mutate(
    PAAS_OH = as.numeric(str_extract(PAAS_OH, "\\d+(\\.\\d+)?")),
    BORG_OH = as.numeric(str_extract(BORG_OH, "\\d+(\\.\\d+)?"))
  ) %>%
  inner_join(rotation_TH, by = "UserID") %>%
  rename(
    PAAS_TH = Mentally_demanding,
    BORG_TH = Physically_demanding
  ) %>%
  mutate(
    PAAS_TH = as.numeric(str_extract(PAAS_TH, "\\d+(\\.\\d+)?")),
    BORG_TH = as.numeric(str_extract(BORG_TH, "\\d+(\\.\\d+)?"))
  ) %>%  
  inner_join(rotation_preference, by = "UserID") %>%
  rename(
    behaviour_preference = Rotation_preference,
    behaviour_feedback = Rotation_feedback
  ) %>%
  mutate(
      behaviour_preference = case_when(
    str_detect(behaviour_preference, "One-handed") ~ "oneHandedPreference",
    str_detect(behaviour_preference, "Two-handed") ~ "twoHandedPreference",
    str_detect(behaviour_preference, "no preference") ~ "noPreference",
    TRUE ~ "unknown"
  )) %>%
  filter(Type == "rotationTask") %>%
  select(UserID, TaskID, ActionID, oneHandedRotationGesture, complexity, Date, ActionStatus, main_rotation_x,
  main_rotation_y, main_rotation_z, main_rotation_w, target_rotation_x, target_rotation_y, target_rotation_z,
  target_rotation_w,match_accuracy_result, status, PAAS_OH, BORG_OH, PAAS_TH, BORG_TH, behaviour_preference, behaviour_feedback) %>%
  mutate(rotationCondition = if_else(oneHandedRotationGesture, "oneHanded", "twoHanded")) %>%
  select(-oneHandedRotationGesture) %>%
  mutate(complexity = as.factor(complexity), 
         rotationCondition = as.factor(rotationCondition),
         status = as.factor(status),
         behaviour_preference = as.factor(behaviour_preference))

```

### Rotation Task Study
```{r Rotation Task Study}
### Accuracy
#### Normality
data.rotating.matched <- data.rotating %>%
  filter(status == "Matched")

shapiro.test(data.rotating.matched$match_accuracy_result)

hist(data.rotating.matched$match_accuracy_result, breaks = 100,
     main = "Histogram (Zoomed)", xlab = "Accuracy",
     col = "lightblue", xlim = c(0, 0.5))

plot(density(data.rotating.matched$match_accuracy_result), 
     main = "Density Plot (Zoomed)", xlab = "Accuracy",
     col = "blue", lwd = 2, xlim = c(0, 0.5))

# Although the w value is close to 1, the p value is below 0.05 so we reject null hypothesis that the data is normally distributed
# So, we cannot use one way ANOVA, instead, we use Wilcoxon signed-rank test

#### Statistical tests 
data.rotating.matched.accuracy_avg.long <- data.rotating.matched %>%
  group_by(UserID, rotationCondition) %>%
  summarise(mean_accuracy = mean(match_accuracy_result, na.rm = TRUE), .groups = 'drop') 

data.rotating.matched.art <- art(mean_accuracy ~ rotationCondition + (1|UserID), data = data.rotating.matched.accuracy_avg.long)

anova(data.rotating.matched.art)

#	Because p < .05, the result is considered statistically significant.
# Therefore, we reject the null hypothesis and conclude that rotation affects accuracy.

# An ART ANOVA revealed a significant main effect of rotation condition on mean accuracy, F(1, 11) = 6.22, p = .030, indicating that the presence of globe rotation influenced the participants’ accuracy during the task.


ggplot(data.rotating.matched.accuracy_avg.long, aes(x = rotationCondition, y = mean_accuracy, group = UserID)) +
  geom_line(aes(color = as.factor(UserID))) +
  geom_point(size = 3) +
  labs(title = "Paired Accuracy: Moving vs Non-Moving Globe",
       x = "Condition",
       y = "Match Accuracy") +
  theme_minimal()

ggplot(data.rotating.matched.accuracy_avg.long, aes(x = rotationCondition, y = mean_accuracy)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  labs(title = "Accuracy by Globe Movement Condition",
       x = "Condition",
       y = "Match Accuracy") +
  theme_minimal()

### Completion Time
data.rotating.taskCompletion_avg <- data.rotating %>%
  group_by(UserID, TaskID) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  )

shapiro.test(data.rotating.taskCompletion_avg$completion_time)

data.rotating.taskCompletion_avg.long <- data.rotating %>%
  group_by(UserID, rotationCondition, TaskID) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  group_by(UserID, rotationCondition) %>%
  summarise(
    avg_completion_time = mean(completion_time),
    .groups = "drop"
  )

data.rotating.taskCompletion_avg.art <- art(avg_completion_time ~ rotationCondition + (1|UserID), data = data.rotating.taskCompletion_avg.long)

anova(data.rotating.taskCompletion_avg.art)

# F(1, 11) = 6.45, p = 0.027
# Since the p-value is less than 0.05, the result is statistically significant.
# This means that rotationCondition has a significant effect on avg_completion_time.
# 
# An aligned rank transform ANOVA revealed a significant effect of rotation condition on task completion time, F(1, 11) = 6.45, p = .027.

ggplot(data.rotating.taskCompletion_avg.long, aes(x = rotationCondition, y = avg_completion_time, group = UserID)) +
  geom_line(aes(color = as.factor(UserID)), linewidth = 1, alpha = 0.6) +
  geom_point(size = 3) +
  labs(
    title = "Task Completion Time by Condition",
    x = "Condition",
    y = "Completion Time (minutes)",
    color = "UserID"
  ) +
  theme_minimal()

ggplot(data.rotating.taskCompletion_avg.long, aes(x = rotationCondition, y = avg_completion_time)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  labs(title = "Accuracy by Globe Movement Condition",
       x = "Condition",
       y = "Match Accuracy") +
  theme_minimal()
### Subjective Measures
#### Physical and Mental Exertion
# Spearman’s rank correlation is a non-parametric test.
# It does not assume normal distribution of the variables.
# It works on ranks of the data, not the raw values — so it’s robust against skewed or non-normal distributions.

data.rotating.matched.OH <- data.rotating.matched %>% 
  filter(rotationCondition == "oneHanded")

cor.test(data.rotating.matched.OH$BORG_OH, 
         data.rotating.matched.OH$match_accuracy_result, method = "spearman")

ggplot(data.rotating.matched.OH, aes(x = BORG_OH, y = match_accuracy_result)) +
  geom_point(color = "steelblue", size = 2, alpha = 0.7) +
  geom_smooth(method = "loess", color = "darkred", se = TRUE) +
  labs(
    title = "Correlation between Physical Exertion and Accuracy (One Handed)",
    x = "Physical Exertion (BORG_OH)",
    y = "Match Accuracy Result"
  ) +
  theme_minimal()

data.rotating.matched.TH <- data.rotating.matched %>% 
  filter(rotationCondition == "twoHanded")

cor.test(data.rotating.matched.TH$BORG_TH, 
         data.rotating.matched.TH$match_accuracy_result, method = "spearman")

ggplot(data.rotating.matched.TH, aes(x = BORG_TH, y = match_accuracy_result)) +
  geom_point(color = "steelblue", size = 2, alpha = 0.7) +
  geom_smooth(method = "loess", color = "darkred", se = TRUE) +
  labs(
    title = "Correlation between Physical Exertion and Accuracy (Two Handed)",
    x = "Physical Exertion (BORG_TH)",
    y = "Match Accuracy Result"
  ) +
  theme_minimal()

data.rotating.taskCompletion_avg.OH <- data.rotating %>%
  group_by(UserID, rotationCondition, PAAS_OH, BORG_OH, TaskID) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  filter(rotationCondition == "oneHanded")

cor.test(data.rotating.taskCompletion_avg.OH$BORG_OH, 
         data.rotating.taskCompletion_avg.OH$completion_time, method = "spearman")

data.rotating.taskCompletion_avg.TH <- data.rotating %>%
  group_by(UserID, rotationCondition, PAAS_TH, BORG_TH, TaskID) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  filter(rotationCondition == "twoHanded")

cor.test(data.rotating.taskCompletion_avg.TH$BORG_TH, 
         data.rotating.taskCompletion_avg.TH$completion_time, method = "spearman")

# PAAS vs Accuracy
data.rotating.matched.OH$condition <- "OH"
data.rotating.matched.TH$condition <- "TH"

data.rotating.matched.PAAS_combined <- bind_rows(
  data.rotating.matched.OH %>% rename(PAAS = PAAS_OH),
  data.rotating.matched.TH %>% rename(PAAS = PAAS_TH)
)

ggplot(data.rotating.matched.PAAS_combined, aes(x = PAAS, y = match_accuracy_result, color = condition)) +
  geom_point(alpha = 0.7) +
  geom_smooth(method = "lm", se = TRUE) +
  labs(
    title = "Mental Exertion vs Match Accuracy in Rotating",
    x = "PAAS Scale",
    y = "Match Accuracy",
    color = "Condition"
  ) +
  scale_color_manual(values = c("OH" = "blue", "TH" = "red")) +
  theme_minimal()

# PAAS vs Completion Time

data.rotating.taskCompletion_avg.OH$condition <- "OH"
data.rotating.taskCompletion_avg.TH$condition <- "TH"

data.rotating.taskCompletion_avg.PAAS_combined <- bind_rows(
  data.rotating.taskCompletion_avg.OH %>% 
    rename(PAAS = PAAS_OH),
  data.rotating.taskCompletion_avg.TH %>% 
    rename(PAAS = PAAS_TH)
)

ggplot(data.rotating.taskCompletion_avg.PAAS_combined, aes(x = PAAS, y = completion_time, color = condition)) +
  geom_point(alpha = 0.7) +
  geom_smooth(method = "lm", se = TRUE) +
  labs(
    title = "Mental Exertion vs Completion Time in Rotating",
    x = "PASS Scale",
    y = "Completion Time",
    color = "Condition"
  ) +
  scale_color_manual(values = c("RG" = "blue", "NRG" = "red")) +
  theme_minimal()

# BORG vs Accuracy

data.rotating.matched.OH$condition <- "OH"
data.rotating.matched.TH$condition <- "TH"

data.rotating.matched.BORG_combined <- bind_rows(
  data.rotating.matched.OH %>% rename(BORG = BORG_OH),
  data.rotating.matched.TH %>% rename(BORG = BORG_TH)
)

ggplot(data.rotating.matched.BORG_combined, aes(x = BORG, y = match_accuracy_result, color = condition)) +
  geom_point(alpha = 0.7) +
  geom_smooth(method = "lm", se = TRUE) +
  labs(
    title = "Physical Exertion vs Match Accuracy in Rotating",
    x = "BORG Scale",
    y = "Match Accuracy",
    color = "Condition"
  ) +
  scale_color_manual(values = c("OH" = "blue", "TH" = "red")) +
  theme_minimal()

# BORG vs Completion Time

data.rotating.taskCompletion_avg.OH$condition <- "OH"
data.rotating.taskCompletion_avg.TH$condition <- "TH"

data.rotating.taskCompletion_avg.BORG_combined <- bind_rows(
  data.rotating.taskCompletion_avg.OH %>% 
    rename(BORG = BORG_OH),
  data.rotating.taskCompletion_avg.TH %>% 
    rename(BORG = BORG_TH)
)

ggplot(data.rotating.taskCompletion_avg.BORG_combined, aes(x = BORG, y = completion_time, color = condition)) +
  geom_point(alpha = 0.7) +
  geom_smooth(method = "lm", se = TRUE) +
  labs(
    title = "Physical Exertion vs Completion Time in Rotating",
    x = "BORG Scale",
    y = "Completion Time (min)",
    color = "Condition"
  ) +
  scale_color_manual(values = c("OH" = "blue", "TH" = "red")) +
  theme_minimal()
#### Preference
data.rotating %>%
  select(UserID, behaviour_preference) %>%
  distinct() %>%  
  count(behaviour_preference) %>%
  mutate(
    percent = n / sum(n),
    ncount = paste0(n, "\n", percent_format()(percent))
  ) %>%
  ggplot(aes(x = "", y = n, fill = behaviour_preference)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = ncount), position = position_stack(vjust = 0.5), size = 4) +
  labs(
    title = "Distribution of Rotation Behaviour Preferences",
    fill = "Preference"
  ) +
  theme_void()
#### Comments
data.rotating.preference.summary <- data.rotating %>%
  mutate(
    behaviour_preference = case_when(
      behaviour_preference == "oneHandedPreference" ~ "One Handed Gesture",
      behaviour_preference == "twoHandedPreference" ~ "Two Handed Gesture",
      behaviour_preference == "noPreference" ~ "No Preference",
      TRUE ~ behaviour_preference
    )
  ) %>%
  group_by(UserID) %>%
  summarise(
    behaviour_preference = first(behaviour_preference),
    behaviour_feedback = first(behaviour_feedback),
    .groups = "drop"
  )

kable(data.rotating.preference.summary, caption = "User Feedback Summary - Rotating")
### Summary
```

## Study: Scale
### Scale Data Preparation
```{r Scale Data Preparation}
data.scale <- data %>%
  inner_join(demographic, by = "UserID") %>%
  inner_join(scale_MG, by = "UserID") %>%
    rename(
    PAAS_MG = Mentally_demanding,
    BORG_MG = Physically_demanding
  ) %>%
  mutate(
    PAAS_MG = as.numeric(str_extract(PAAS_MG, "\\d+(\\.\\d+)?")),
    BORG_MG = as.numeric(str_extract(BORG_MG, "\\d+(\\.\\d+)?"))
  ) %>%
  inner_join(scale_NMG, by = "UserID") %>%
  rename(
    PAAS_NMG = Mentally_demanding,
    BORG_NMG = Physically_demanding
  ) %>%
  mutate(
    PAAS_NMG = as.numeric(str_extract(PAAS_NMG, "\\d+(\\.\\d+)?")),
    BORG_NMG = as.numeric(str_extract(BORG_NMG, "\\d+(\\.\\d+)?"))
  ) %>%
  inner_join(scale_preference, by = "UserID") %>%
  rename(
    behaviour_preference = Scale_preference,
    behaviour_feedback = Scale_feedback
  ) %>%
  mutate(
    behaviour_preference = case_when(
    str_detect(behaviour_preference, "Maintain distance") ~ "maintainDistance",
    str_detect(behaviour_preference, "Maintain globe") ~ "maintainGlobe",
    str_detect(behaviour_preference, "no preference") ~ "noPreference",
    TRUE ~ "unknown"
  )) %>%
  filter(Type == "scaleTask") %>%
  select(UserID, TaskID, ActionID, moveGlobeWhileScaling, zoomDirection, Date, ActionStatus, main_scale_x,
  main_scale_y, main_scale_z, target_scale_x, target_scale_y, target_scale_z, match_accuracy_result, status,
  PAAS_MG, BORG_MG, PAAS_NMG, BORG_NMG, behaviour_preference, behaviour_feedback) %>%
  mutate(scaleCondition = if_else(moveGlobeWhileScaling, "movingGlobe", "nonMovingGlobe")) %>%
  select(-moveGlobeWhileScaling) %>%
  mutate(zoomDirection = as.factor(zoomDirection), 
         scaleCondition = as.factor(scaleCondition),
         status = as.factor(status),
         behaviour_preference = as.factor(behaviour_preference))

```

### Scale Task Study
```{r Scale Task Study}
### Accuracy
#### Normality
data.scale.matched <- data.scale %>%
  filter(status == "Matched")

shapiro.test(data.scale.matched$match_accuracy_result)

hist(data.scale.matched$match_accuracy_result, breaks = 100,
     main = "Histogram (Zoomed)", xlab = "Accuracy",
     col = "lightblue", xlim = c(0, 0.5))

plot(density(data.scale.matched$match_accuracy_result), 
     main = "Density Plot (Zoomed)", xlab = "Accuracy",
     col = "blue", lwd = 2, xlim = c(0, 0.5))

# Although the w value is close to 1, the p value is below 0.05 so we reject null hypothesis that the data is normally distributed
# So, we cannot use one way ANOVA, instead, we use Wilcoxon signed-rank test

#### Statistical tests 
data.scale.matched.accuracy_avg.long <- data.scale.matched %>%
  group_by(UserID, scaleCondition) %>%
  summarise(mean_accuracy = mean(match_accuracy_result, na.rm = TRUE), .groups = 'drop')
  # %>%
  # pivot_wider(names_from = scaleCondition, values_from = mean_accuracy)

data.scale.matched.art <- art(mean_accuracy ~ scaleCondition + (1|UserID), data = data.scale.matched.accuracy_avg.long)

anova(data.scale.matched.art)

# Because p > .05, we fail to reject the null hypothesis.
# There is no evidence that changing the scale condition affects how accurately participants performed.

# An ART ANOVA showed no significant effect of scale condition on mean accuracy, F(1, 11) = 0.44, p = .522, indicating that changing the scale of the globe did not impact participants’ accuracy.

ggplot(data.scale.matched.accuracy_avg.long, aes(x = scaleCondition, y = mean_accuracy, group = UserID)) +
  geom_line(aes(color = as.factor(UserID))) +
  geom_point(size = 3) +
  labs(title = "Paired Accuracy: Moving vs Non-Moving Globe",
       x = "Condition",
       y = "Match Accuracy") +
  theme_minimal()

ggplot(data.scale.matched.accuracy_avg.long, aes(x = scaleCondition, y = mean_accuracy)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  labs(title = "Accuracy by Globe Movement Condition",
       x = "Condition",
       y = "Match Accuracy") +
  theme_minimal()

### Completion Time
data.scale.taskCompletion_avg <- data.scale %>%
  group_by(UserID, TaskID) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  )

shapiro.test(data.scale.taskCompletion_avg$completion_time)

data.scale.taskCompletion_avg.long <- data.scale %>%
  group_by(UserID, scaleCondition, TaskID) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  group_by(UserID, scaleCondition) %>%
  summarise(
    avg_completion_time = mean(completion_time),
    .groups = "drop"
  ) 
  # %>%
  # pivot_wider(names_from = scaleCondition, values_from = avg_completion_time)

data.scale.taskCompletion.art <- art(avg_completion_time ~ scaleCondition + (1|UserID), data = data.scale.taskCompletion_avg.long)

anova(data.scale.matched.art)

# An aligned rank transform (ART) ANOVA revealed no significant effect of scale condition on mean accuracy, F(1, 11) = 0.44, p = .522.
# There was no significant effect of scale condition on mean accuracy, F(1, 11) = 0.44, p = .522.

# wilcox.test(
#   data.scale.taskCompletion_avg.wide$movingGlobe,
#   data.scale.taskCompletion_avg.wide$nonMovingGlobe,
#   paired = TRUE,
#   alternative = "two.sided"
# )

# data.scale.taskCompletion_avg.long <- data.scale.taskCompletion_avg.wide %>%
#   pivot_longer(cols = c(movingGlobe, nonMovingGlobe),
#                names_to = "Condition",
#                values_to = "completion_time")

ggplot(data.scale.taskCompletion_avg.long, aes(x = scaleCondition, y = avg_completion_time, group = UserID)) +
  geom_line(aes(color = as.factor(UserID)), linewidth = 1, alpha = 0.6) +
  geom_point(size = 3) +
  labs(
    title = "Task Completion Time by Condition",
    x = "Condition",
    y = "Completion Time (minutes)",
    color = "UserID"
  ) +
  theme_minimal()

ggplot(data.scale.taskCompletion_avg.long, aes(x = scaleCondition, y = avg_completion_time)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  labs(title = "Accuracy by Globe Movement Condition",
       x = "Condition",
       y = "Match Accuracy") +
  theme_minimal()
### Subjective Measures
#### Physical Exertion
# Spearman’s rank correlation is a non-parametric test.
# It does not assume normal distribution of the variables.
# It works on ranks of the data, not the raw values — so it’s robust against skewed or non-normal distributions.

data.scale.matched.MG <- data.scale.matched %>% 
  filter(scaleCondition == "movingGlobe")

cor.test(data.scale.matched.MG$BORG_MG, 
         data.scale.matched.MG$match_accuracy_result, method = "spearman")

ggplot(data.scale.matched.MG, aes(x = BORG_MG, y = match_accuracy_result)) +
  geom_point(color = "steelblue", size = 2, alpha = 0.7) +
  geom_smooth(method = "loess", color = "darkred", se = TRUE) +
  labs(
    title = "Correlation between Physical Exertion and Accuracy (Moving Globe)",
    x = "Physical Exertion (BORG_MG)",
    y = "Match Accuracy Result"
  ) +
  theme_minimal()

data.scale.matched.NMG <- data.scale.matched %>% 
  filter(scaleCondition == "nonMovingGlobe")

cor.test(data.scale.matched.NMG$BORG_NMG, 
         data.scale.matched.NMG$match_accuracy_result, method = "spearman")

ggplot(data.scale.matched.NMG, aes(x = BORG_NMG, y = match_accuracy_result)) +
  geom_point(color = "steelblue", size = 2, alpha = 0.7) +
  geom_smooth(method = "loess", color = "darkred", se = TRUE) +
  labs(
    title = "Correlation between Physical Exertion and Accuracy (Non-moving Globe)",
    x = "Physical Exertion (BORG_NMG)",
    y = "Match Accuracy Result"
  ) +
  theme_minimal()

data.scale.taskCompletion_avg.MG <- data.scale %>%
  group_by(UserID, scaleCondition, PAAS_MG, BORG_MG, TaskID) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  filter(scaleCondition == "movingGlobe")

cor.test(data.scale.taskCompletion_avg.MG$BORG_MG, 
         data.scale.taskCompletion_avg.MG$completion_time, method = "spearman")

data.scale.taskCompletion_avg.NMG <- data.scale %>%
  group_by(UserID, scaleCondition, PAAS_NMG, BORG_NMG, TaskID) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  filter(scaleCondition == "nonMovingGlobe")

cor.test(data.scale.taskCompletion_avg.NMG$BORG_NMG, 
         data.scale.taskCompletion_avg.NMG$completion_time, method = "spearman")

# PAAS vs Accuracy
data.scale.matched.MG$condition <- "MG"
data.scale.matched.NMG$condition <- "NMG"

data.scale.matched.PAAS_combined <- bind_rows(
  data.scale.matched.MG %>% rename(PAAS = PAAS_MG),
  data.scale.matched.NMG %>% rename(PAAS = PAAS_NMG)
)

ggplot(data.scale.matched.PAAS_combined, aes(x = PAAS, y = match_accuracy_result, color = condition)) +
  geom_point(alpha = 0.7) +
  geom_smooth(method = "lm", se = TRUE) +
  labs(
    title = "Mental Exertion vs Match Accuracy in scale",
    x = "PAAS Scale",
    y = "Match Accuracy",
    color = "Condition"
  ) +
  scale_color_manual(values = c("MG" = "blue", "NMG" = "red")) +
  theme_minimal()

# PAAS vs Completion Time

data.scale.taskCompletion_avg.MG$condition <- "MG"
data.scale.taskCompletion_avg.NMG$condition <- "NMG"

data.scale.taskCompletion_avg.PAAS_combined <- bind_rows(
  data.scale.taskCompletion_avg.MG %>% 
    rename(PAAS = PAAS_MG),
  data.scale.taskCompletion_avg.NMG %>% 
    rename(PAAS = PAAS_NMG)
)

ggplot(data.scale.taskCompletion_avg.PAAS_combined, aes(x = PAAS, y = completion_time, color = condition)) +
  geom_point(alpha = 0.7) +
  geom_smooth(method = "lm", se = TRUE) +
  labs(
    title = "Mental Exertion vs Completion Time in scale",
    x = "PASS Scale",
    y = "Completion Time",
    color = "Condition"
  ) +
  scale_color_manual(values = c("MG" = "blue", "NMG" = "red")) +
  theme_minimal()

# BORG vs Accuracy
data.scale.matched.MG$condition <- "MG"
data.scale.matched.NMG$condition <- "NMG"

data.scale.matched.BORG_combined <- bind_rows(
  data.scale.matched.MG %>% rename(BORG = BORG_MG),
  data.scale.matched.NMG %>% rename(BORG = BORG_NMG)
)

ggplot(data.scale.matched.BORG_combined, aes(x = BORG, y = match_accuracy_result, color = condition)) +
  geom_point(alpha = 0.7) +
  geom_smooth(method = "lm", se = TRUE) +
  labs(
    title = "Physical Exertion vs Match Accuracy",
    x = "BORG Scale",
    y = "Match Accuracy",
    color = "Condition"
  ) +
  scale_color_manual(values = c("RG" = "blue", "NRG" = "red")) +
  theme_minimal()

# BORG vs Completion Time

data.scale.taskCompletion_avg.MG$condition <- "RG"
data.scale.taskCompletion_avg.NMG$condition <- "NRG"

data.scale.taskCompletion_avg.BORG_combined <- bind_rows(
  data.scale.taskCompletion_avg.MG %>% 
    rename(BORG = BORG_MG),
  data.scale.taskCompletion_avg.NMG %>% 
    rename(BORG = BORG_NMG)
)

ggplot(data.scale.taskCompletion_avg.BORG_combined, aes(x = BORG, y = completion_time, color = condition)) +
  geom_point(alpha = 0.7) +
  geom_smooth(method = "lm", se = TRUE) +
  labs(
    title = "Physical Exertion vs Completion Time",
    x = "BORG Scale",
    y = "Completion Time (min)",
    color = "Condition"
  ) +
  scale_color_manual(values = c("MG" = "blue", "NMG" = "red")) +
  theme_minimal()

#### Preference
data.scale %>%
  select(UserID, behaviour_preference) %>%
  distinct() %>%  
  count(behaviour_preference) %>%
  mutate(
    percent = n / sum(n),
    ncount = paste0(n, "\n", percent_format()(percent))
  ) %>%
  ggplot(aes(x = "", y = n, fill = behaviour_preference)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = ncount), position = position_stack(vjust = 0.5), size = 4) +
  labs(
    title = "Distribution of Scale Behaviour Preferences",
    fill = "Preference"
  ) +
  theme_void()
  

#### Comments
data.scale.preference.summary <- data.scale %>%
  mutate(
    behaviour_preference = case_when(
      behaviour_preference == "maintainDistance" ~ "Maintain Globe's Distance",
      behaviour_preference == "maintainGlobe" ~ "Maintain Globe's Position",
      behaviour_preference == "noPreference" ~ "No Preference",
      TRUE ~ behaviour_preference
    )
  ) %>%
  group_by(UserID) %>%
  summarise(
    behaviour_preference = first(behaviour_preference),
    behaviour_feedback = first(behaviour_feedback),
    .groups = "drop"
  )

kable(data.scale.preference.summary, caption = "User Feedback Summary - Scale")
### Summary
```
---
title: "Gestures for Positioning, Scaling, and Rotating Virtual Globes"
author: "Faisal Agung Abdillah"
date: "2025-05-08"
output:
  html_document:
    code_folding: show
    toc: true
    toc_float: true
    toc_depth: 6
    theme: flatly
    highlight: haddock
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Gestures for Globes Research

## Data and Libraries Load

```{r}
library(tidyverse)
library(dplyr)
library(car)
library(ggplot2)
library(lubridate)
library(scales)
library(ARTool)
library(knitr)
library(kableExtra)
library(patchwork)
library(emmeans)


data <- read_csv("study_tasks.csv")
demographic <- read_csv("final_introductory.csv")
positioning_NRG <- read_csv("final_positioning_NRG.csv")
positioning_RG <- read_csv("final_positioning_RG.csv")
positioning_preference <- read_csv("final_positioning_comparison.csv")
rotation_OH <- read_csv("final_rotation_OH.csv")
rotation_TH <- read_csv("final_rotation_TH.csv")
rotation_preference <- read_csv("final_rotation_comparison.csv")
scale_MG <- read_csv("final_scale_MG.csv")
scale_NMG <- read_csv("final_scale_NMG.csv")
scale_preference <- read_csv("final_scale_comparison.csv")
combined_preference <- read_csv("final_outro_comparison.csv")

summary(data)

summary(demographic)

summary(positioning_NRG)

summary(positioning_RG)

summary(positioning_preference)

summary(rotation_OH)

summary(rotation_TH)

summary(rotation_preference)

summary(scale_MG)

summary(scale_NMG)

summary(scale_preference)

summary(combined_preference)
```

## General Data Preparation & Restructuring

Restructure the data for better analysis

```{r Data - restructure}

# Positioning

data.positioning.accuracy <- data %>%
  filter(Type == "positionTask") %>%
  select(UserID, TaskID, rotateGlobeWhileDragging, match_accuracy_result, status) %>%
  filter(status == "Matched") %>%
  select(-status) %>%
  mutate(Technique = if_else(rotateGlobeWhileDragging, "rotatingGlobe", "nonRotatingGlobe")) %>%
  select(-rotateGlobeWhileDragging) %>%
  rename("Accuracy" = "match_accuracy_result")
  
data.positioning.time <- data %>%
  filter(Type == "positionTask") %>%
  select(UserID, TaskID, rotateGlobeWhileDragging, Date) %>%
  group_by(UserID, TaskID, rotateGlobeWhileDragging) %>%
  summarise(
    Time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  mutate(Technique = if_else(rotateGlobeWhileDragging, "rotatingGlobe", "nonRotatingGlobe")) %>%
  select(-rotateGlobeWhileDragging)
  
data.positioning.borg <- data %>%
  filter(Type == "positionTask") %>%
  mutate(Technique = if_else(rotateGlobeWhileDragging, "rotatingGlobe", "nonRotatingGlobe")) %>%
  select(UserID, Technique) %>%
  distinct() %>%
  inner_join(positioning_NRG, by = "UserID") %>%
  rename(BORG_NRG = Physically_demanding) %>%
  select(-Timestamp, -Mentally_demanding) %>%
  mutate(BORG_NRG = as.numeric(str_extract(BORG_NRG, "\\d+(\\.\\d+)?"))) %>%
  inner_join(positioning_RG, by = "UserID") %>%
  rename(BORG_RG = Physically_demanding) %>%
  select(-Timestamp, -Mentally_demanding) %>%
  mutate(BORG_RG = as.numeric(str_extract(BORG_RG, "\\d+(\\.\\d+)?"))) %>%
  mutate(
    BORGRPE = if_else(Technique == "rotatingGlobe", BORG_RG, BORG_NRG)
  ) %>%
  select(-BORG_RG, -BORG_NRG)

data.positioning.paas <- data %>%
  filter(Type == "positionTask") %>%
  mutate(Technique = if_else(rotateGlobeWhileDragging, "rotatingGlobe", "nonRotatingGlobe")) %>%
  select(UserID, Technique) %>%
  distinct() %>%
  inner_join(positioning_NRG, by = "UserID") %>%
  rename(PAAS_NRG = Mentally_demanding) %>%
  select(-Timestamp, -Physically_demanding) %>%
  mutate(PAAS_NRG = as.numeric(str_extract(PAAS_NRG, "\\d+(\\.\\d+)?"))) %>%
  inner_join(positioning_RG, by = "UserID") %>%
  rename(PAAS_RG = Mentally_demanding) %>%
  select(-Timestamp, -Physically_demanding) %>%
  mutate(PAAS_RG = as.numeric(str_extract(PAAS_RG, "\\d+(\\.\\d+)?"))) %>%
  mutate(
    PAAS = if_else(Technique == "rotatingGlobe", PAAS_RG, PAAS_NRG)
  ) %>%
  select(-PAAS_RG, -PAAS_NRG)

data.positioning.qualitative <- positioning_preference %>%
  select(-Timestamp) %>%
  mutate(
    Positioning_preference = case_when(
      str_detect(Positioning_preference, "Static orientation") ~ "staticOrientation",
      str_detect(Positioning_preference, "Adaptive orientation") ~ "adaptiveOrientation",
      str_detect(Positioning_preference, "no preference") ~ "noPreference",
      TRUE ~ "unknown"
    ),
    Positioning_preference = as.factor(Positioning_preference)
  )

# Rotating

data.rotating.accuracy <- data %>%
  filter(Type == "rotationTask") %>%
  select(UserID, TaskID, oneHandedRotationGesture, match_accuracy_result, status) %>%
  filter(status == "Matched") %>%
  select(-status) %>%
  mutate(Technique = if_else(oneHandedRotationGesture, "oneHanded", "twoHanded")) %>%
  select(-oneHandedRotationGesture) %>%
  rename("Accuracy" = "match_accuracy_result")

data.rotating.time <- data %>%
  filter(Type == "rotationTask") %>%
  select(UserID, TaskID, oneHandedRotationGesture, Date) %>%
  group_by(UserID, TaskID, oneHandedRotationGesture) %>%
  summarise(
    Time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  mutate(Technique = if_else(oneHandedRotationGesture, "oneHanded", "twoHanded")) %>%
  select(-oneHandedRotationGesture)

data.rotating.borg <- data %>%
  filter(Type == "rotationTask") %>%
  mutate(Technique = if_else(oneHandedRotationGesture, "oneHanded", "twoHanded")) %>%
  select(UserID, Technique) %>%
  distinct() %>%
  inner_join(rotation_OH, by = "UserID") %>%
  rename(BORG_OH = Physically_demanding) %>%
  select(-Timestamp, -Mentally_demanding) %>%
  mutate(BORG_OH = as.numeric(str_extract(BORG_OH, "\\d+(\\.\\d+)?"))) %>%
  inner_join(rotation_TH, by = "UserID") %>%
  rename(BORG_TH = Physically_demanding) %>%
  select(-Timestamp, -Mentally_demanding) %>%
  mutate(BORG_TH = as.numeric(str_extract(BORG_TH, "\\d+(\\.\\d+)?"))) %>%
  mutate(
    BORGRPE = if_else(Technique == "oneHanded", BORG_OH, BORG_TH)
  ) %>%
  select(-BORG_OH, -BORG_TH)

data.rotating.paas <- data %>%
  filter(Type == "rotationTask") %>%
  mutate(Technique = if_else(oneHandedRotationGesture, "oneHanded", "twoHanded")) %>%
  select(UserID, Technique) %>%
  distinct() %>%
  inner_join(rotation_OH, by = "UserID") %>%
  rename(PAAS_OH = Mentally_demanding) %>%
  select(-Timestamp, -Physically_demanding) %>%
  mutate(PAAS_OH = as.numeric(str_extract(PAAS_OH, "\\d+(\\.\\d+)?"))) %>%
  inner_join(rotation_TH, by = "UserID") %>%
  rename(PAAS_TH = Mentally_demanding) %>%
  select(-Timestamp, -Physically_demanding) %>%
  mutate(PAAS_TH = as.numeric(str_extract(PAAS_TH, "\\d+(\\.\\d+)?"))) %>%
  mutate(
    PAAS = if_else(Technique == "oneHanded", PAAS_OH, PAAS_TH)
  ) %>%
  select(-PAAS_OH, -PAAS_TH)

data.rotating.qualitative <- rotation_preference %>%
  select(-Timestamp) %>%
  mutate(
    Rotation_preference = case_when(
    str_detect(Rotation_preference, "One-handed") ~ "oneHandedPreference",
    str_detect(Rotation_preference, "Two-handed") ~ "twoHandedPreference",
    str_detect(Rotation_preference, "no preference") ~ "noPreference",
    TRUE ~ "unknown"
    ),   
    Rotation_preference = as.factor(Rotation_preference)
  ) 

# Scale

data.scale.accuracy <- data %>%
  filter(Type == "scaleTask") %>%
  select(UserID, TaskID, moveGlobeWhileScaling, match_accuracy_result, status) %>%
  filter(status == "Matched") %>%
  select(-status) %>%
  mutate(Technique = if_else(moveGlobeWhileScaling, "movingGlobe", " nonMovingGlobe")) %>%
  select(-moveGlobeWhileScaling) %>%
  rename("Accuracy" = "match_accuracy_result")

data.scale.time <- data %>%
  filter(Type == "scaleTask") %>%
  select(UserID, TaskID, moveGlobeWhileScaling, Date) %>%
  group_by(UserID, TaskID, moveGlobeWhileScaling) %>%
  summarise(
    Time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  mutate(Technique = if_else(moveGlobeWhileScaling, "movingGlobe", "nonMovingGLobe")) %>%
  select(-moveGlobeWhileScaling)

data.scale.borg <- data %>%
  filter(Type == "scaleTask") %>%
  mutate(Technique = if_else(moveGlobeWhileScaling, "movingGlobe", "nonMovingGlobe")) %>%
  select(UserID, Technique) %>%
  distinct() %>%
  inner_join(scale_NMG, by = "UserID") %>%
  rename(BORG_NMG = Physically_demanding) %>%
  select(-Timestamp, -Mentally_demanding) %>%
  mutate(BORG_NMG = as.numeric(str_extract(BORG_NMG, "\\d+(\\.\\d+)?"))) %>%
  inner_join(scale_MG, by = "UserID") %>%
  rename(BORG_MG = Physically_demanding) %>%
  select(-Timestamp, -Mentally_demanding) %>%
  mutate(BORG_MG = as.numeric(str_extract(BORG_MG, "\\d+(\\.\\d+)?"))) %>%
  mutate(
    BORGRPE = if_else(Technique == "movingGlobe", BORG_MG, BORG_NMG)
  ) %>%
  select(-BORG_MG, -BORG_NMG)

data.scale.paas <- data %>%
  filter(Type == "scaleTask") %>%
  mutate(Technique = if_else(moveGlobeWhileScaling, "movingGlobe", "nonMovingGlobe")) %>%
  select(UserID, Technique) %>%
  distinct() %>%
  inner_join(scale_NMG, by = "UserID") %>%
  rename(PAAS_NMG = Mentally_demanding) %>%
  select(-Timestamp, -Physically_demanding) %>%
  mutate(PAAS_NMG = as.numeric(str_extract(PAAS_NMG, "\\d+(\\.\\d+)?"))) %>%
  inner_join(scale_MG, by = "UserID") %>%
  rename(PAAS_MG = Mentally_demanding) %>%
  select(-Timestamp, -Physically_demanding) %>%
  mutate(PAAS_MG = as.numeric(str_extract(PAAS_MG, "\\d+(\\.\\d+)?"))) %>%
  mutate(
    PAAS = if_else(Technique == "movingGlobe", PAAS_MG, PAAS_NMG)
  ) %>%
  select(-PAAS_MG, -PAAS_NMG)

data.scale.qualitative <- scale_preference %>%
  select(-Timestamp) %>%
  mutate(
    Scale_preference = case_when(
    str_detect(Scale_preference, "Maintain distance") ~ "maintainDistance",
    str_detect(Scale_preference, "Maintain globe") ~ "maintainGlobe",
    str_detect(Scale_preference, "no preference") ~ "noPreference",
    TRUE ~ "unknown"
    ),
    Scale_preference = as.factor(Scale_preference)
  ) 

# Combined qualitative

data.combined.qualitative <- combined_preference %>%
  select(-Timestamp) %>%
  rename(
    Positioning_preference = Combined_positioning_preference,
    Rotation_preference = Combined_rotation_preference,
    Scale_preference = Combined_scale_preference
  ) %>%
  mutate(
    Positioning_preference = case_when(
      str_detect(Positioning_preference, "Static orientation") ~ "staticOrientation",
      str_detect(Positioning_preference, "Adaptive orientation") ~ "adaptiveOrientation",
      str_detect(Positioning_preference, "No preference") ~ "noPreference",
      TRUE ~ "unknown"
    ),
    Positioning_preference = as.factor(Positioning_preference)
  ) %>%
  mutate(
    Rotation_preference = case_when(
    str_detect(Rotation_preference, "One-handed") ~ "oneHandedPreference",
    str_detect(Rotation_preference, "Two-handed") ~ "twoHandedPreference",
    str_detect(Rotation_preference, "No preference") ~ "noPreference",
    TRUE ~ "unknown"
    ),
    Rotation_preference = as.factor(Rotation_preference)
  ) %>%
  mutate(
    Scale_preference = case_when(
    str_detect(Scale_preference, "Maintain distance") ~ "maintainDistance",
    str_detect(Scale_preference, "Maintain globe") ~ "maintainGlobe",
    str_detect(Scale_preference, "No preference") ~ "noPreference",
    TRUE ~ "unknown"
    ),
    Scale_preference = as.factor(Scale_preference)
  )

```


## Participants Demographic Information


```{r Demographic}
# Total number of participants
length(unique(data$UserID))

# Participants' gender distribution
demographic.gender <-  demographic %>%
  select(UserID, Gender) %>%
  distinct() %>%
  group_by(Gender) %>%
  summarise(count = n()) %>%
  mutate(percentage = round(count / sum(count) * 100, 1), percentage = paste0(percentage, "%"))

demographic.gender

# Participants' gender distribution chart
ggplot(demographic.gender, aes(x = "", y = count, fill = Gender)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = percentage), position = position_stack(vjust = 0.5), size = 4) +
  labs(title = "Distribution of Participants' Gender") +
  theme_void()

# Participants' academic level distribution
demographic.academic_level <-  demographic %>%
  select(UserID, Academic_level) %>%
  distinct() %>%
  group_by(Academic_level) %>%
  summarise(count = n()) %>%
  mutate(percentage = round(count / sum(count) * 100, 1), graph_label = paste0(percentage, "%")) %>%
  rename(`Academic levels` = Academic_level)

demographic.academic_level

# Participants' academic level distribution chart
ggplot(demographic.academic_level, aes(x = "", y = count, fill = `Academic levels`)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = graph_label), position = position_stack(vjust = 0.5), size = 4) +
  labs(title = "Distribution of Participants' Academic Level") +
  theme_void() 

# Participants' previous AR/VR experience distribution
demographic.ARVR_exp <-  demographic %>%
  select(UserID, Exp_ARVR ) %>%
  distinct() %>%
  group_by(Exp_ARVR) %>%
  summarise(count = n()) %>%
  mutate(percentage = round(count / sum(count) * 100, 1), 
         label = paste0(percentage, "%"),
         ShortLabel = fct_recode(Exp_ARVR,
                          "No experience" = "I have no experience")
) %>%
  rename(`Previous AR/VR experience` = ShortLabel)

demographic.ARVR_exp

# Participants' previous AR/VR experience distribution chart
ggplot(demographic.ARVR_exp, aes(x = "", y = count, fill = `Previous AR/VR experience`)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = label), position = position_stack(vjust = 0.5), size = 4) +
  labs(title = "Distribution of Participants Previous AR/VR Experience") +
  theme_void() 

# Participants' previous globe experience distribution
demographic.globes_exp <- demographic %>%
  select(UserID, Globe_usage_frequency) %>%
  distinct() %>%
  group_by(Globe_usage_frequency) %>%
  summarise(count = n()) %>%
  mutate(percentage = round(count / sum(count) * 100, 1),
         graph_label = paste0(percentage, "%")) %>%
  rename(`Previous globes experience` = Globe_usage_frequency)

demographic.globes_exp

# Participants' previous globe experience distribution chart
ggplot(demographic.globes_exp, aes(x = "", y = count, fill = `Previous globes experience`)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = graph_label), position = position_stack(vjust = 0.5), size = 4) +
  labs(title = "Distribution of Participants Previous Globe Experience") +
  theme_void() 

# Participants' previous Apple Vision Pro Experience distribution
demographic.visionpro_exp <- demographic %>%
  select(UserID, Have_used_VisionPro) %>%
  distinct() %>%
  group_by(Have_used_VisionPro) %>%
  summarise(count = n()) %>%
  mutate(
    percentage = round(count / sum(count) * 100, 1),
    graph_label = paste0(percentage, "%")
  ) %>%
  rename(`Have used Apple Vision Pro` = Have_used_VisionPro)
  
demographic.visionpro_exp
  
# Participants' previous Apple Vision Pro Experience distribution chart
ggplot(demographic.visionpro_exp, aes(x = "", y = count, fill = `Have used Apple Vision Pro`)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = graph_label), position = position_stack(vjust = 0.5), size = 4) +
  labs(title = "Distribution of Participants Previous AR/VR Experience") +
  theme_void()   

```

## User Study

### Study: Positioning

#### Positioning Data Preparation

```{r Positioning Data Preparation}
data.positioning <- data %>%
  mutate(positionCondition = if_else(rotateGlobeWhileDragging, "rotatingGlobe", "nonRotatingGlobe")) %>%
  select(-rotateGlobeWhileDragging) %>%
  inner_join(demographic, by = "UserID") %>%
  inner_join(positioning_NRG, by = "UserID") %>%
  rename(
    PAAS_NRG = Mentally_demanding,
    BORG_NRG = Physically_demanding
  ) %>%
  mutate(
    PAAS_NRG = as.numeric(str_extract(PAAS_NRG, "\\d+(\\.\\d+)?")),
    BORG_NRG = as.numeric(str_extract(BORG_NRG, "\\d+(\\.\\d+)?"))
  ) %>%
  mutate(
    PAAS_NRG = if_else(positionCondition == "nonRotatingGlobe", PAAS_NRG, NA_real_),
    BORG_NRG = if_else(positionCondition == "nonRotatingGlobe", BORG_NRG, NA_real_)
  ) %>%
  inner_join(positioning_RG, by = "UserID") %>%
  rename(
    PAAS_RG = Mentally_demanding,
    BORG_RG = Physically_demanding
  ) %>%
  mutate(
    PAAS_RG = as.numeric(str_extract(PAAS_RG, "\\d+(\\.\\d+)?")),
    BORG_RG = as.numeric(str_extract(BORG_RG, "\\d+(\\.\\d+)?"))
  ) %>%
  mutate(
    PAAS_RG = if_else(positionCondition == "rotatingGlobe", PAAS_RG, NA_real_),
    BORG_RG = if_else(positionCondition == "rotatingGlobe", BORG_RG, NA_real_)
  ) %>%
  inner_join(positioning_preference, by = "UserID") %>%
  rename(
    technique_preference = Positioning_preference,
    technique_feedback = Positioning_feedback
  ) %>%
  mutate(
      technique_preference = case_when(
    str_detect(technique_preference, "Static orientation") ~ "staticOrientation",
    str_detect(technique_preference, "Adaptive orientation") ~ "adaptiveOrientation",
    str_detect(technique_preference, "no preference") ~ "noPreference",
    TRUE ~ "unknown"
  ) ) %>%
  filter(Type == "positionTask") %>%
  select(UserID, TaskID, ActionID, positionCondition, distance, direction, Date, ActionStatus, main_translation_x,
  main_translation_y, main_translation_z, target_translation_x, target_translation_y, target_translation_z, 
  match_accuracy_result, status, PAAS_NRG, BORG_NRG, PAAS_RG, BORG_RG, technique_preference, technique_feedback) %>%
  mutate(distance = as.factor(distance), 
         direction = as.factor(direction), 
         positionCondition = as.factor(positionCondition),
         status = as.factor(status),
         technique_preference = as.factor(technique_preference))

```

#### Position Task Study

##### Accuracy

###### Normality

```{r PositionStudy - Accuracy - Normality}

shapiro.test(data.positioning.accuracy$Accuracy)

hist(data.positioning.accuracy$Accuracy, breaks = 100,
     main = "Histogram of Positioning Gestures Accuracy", xlab = "Accuracy",
     col = "lightblue", xlim = c(0, 0.06))

plot(density(data.positioning.accuracy$Accuracy), 
     main = "Density Plot of Positioning Gestures Accuracy", xlab = "Accuracy",
     col = "blue", lwd = 2, xlim = c(0, 0.08))
```

Although the w value is close to 1, the p value is below 0.05 so we reject null hypothesis that the data is normally distributed
So, we cannot use one way ANOVA, instead, we use ART ANOVA test

###### Statistical Tests

```{r PositionStudy - Accuracy - Statistical tests}

data.positioning.matched <- data.positioning %>%
  filter(status == "Matched")

data.positioning.matched.accuracy_avg.long <- data.positioning.matched %>%
  group_by(UserID, positionCondition, distance, direction) %>%
  summarise(mean_accuracy = mean(match_accuracy_result, na.rm = TRUE), .groups = 'drop')

data.positioning.matched.art <- art(mean_accuracy ~ positionCondition * distance * direction + (1|UserID), data = data.positioning.matched.accuracy_avg.long)

anova(data.positioning.matched.art)

art_direction_accuracy <- artlm(data.positioning.matched.art, "direction")

# Pairwise of direction
emmeans_direction_accuracy <- emmeans(art_direction_accuracy, pairwise ~ direction)

emmeans_direction_accuracy$contrasts

	# •	The main effect of positionCondition was not statistically significant: F(1, 99) = 0.89, p = 0.348.
	# •	The main effect of distance was statistically significant: F(1, 99.55) = 8.58, p = 0.0042 (**).
	# •	The main effect of direction was also statistically significant: F(2, 99.53) = 3.51, p = 0.0335 (*).
	# •	The interaction between positionCondition and distance was not significant: F(1, 99) = 0.88, p = 0.349.
	# •	The interaction between positionCondition and direction was not significant: F(2, 99) = 0.22, p = 0.803.
	# •	The interaction between distance and direction was not significant: F(2, 99.51) = 0.25, p = 0.778.
	# •	The three-way interaction (positionCondition × distance × direction) was not significant: F(2, 99) = 1.62, p = 0.202.

# There were significant main effects of both distance and direction on mean accuracy, indicating that participants’ accuracy was influenced independently by how far the task was and from which direction it came. However, positionCondition had no significant effect, and no interaction terms reached statistical significance. This suggests that the combined effects of position, distance, and direction do not differentially impact accuracy beyond the main effects of distance and direction alone.

# Plotting for position techniques
data.positioning.matched.accuracy_avg.long %>%
  group_by(positionCondition) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(positionCondition = case_when(
    positionCondition == "rotatingGlobe" ~ "Adaptive Orientation",
    positionCondition == "nonRotatingGlobe" ~ "Static Orientation",
    TRUE ~ as.character(positionCondition))) %>%
  ggplot(aes(x = positionCondition, y = mean_mean_accuracy, fill = positionCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci), width = 0.2) +
  labs(
    title = "Mean Match Accuracy by Positioning Technique",
    x = "Positioning Technique",
    y = "Mean Accuracy",
    fill = "Positioning Technique"
  ) +
  scale_fill_manual(
    values = c("Adaptive Orientation" = "#a6bddb",  
               "Static Orientation" = "#d0d1e6")  
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text())  

data.positioning.matched.accuracy_avg.long %>%
  group_by(distance) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  ggplot(aes(x = distance, y = mean_mean_accuracy, fill = distance)) +
  geom_col(width = 0.3) +  
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci), width = 0.2) +
  labs(
    x = "Globe Distance",
    y = "Mean Accuracy"
  ) +
  scale_fill_manual(
    values = c(near = "#a6bddb",  
               far = "#d0d1e6")  
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(),
    legend.position = "none"  
  ) +
  coord_flip()

ggsave("Position_distance_bar.svg")

# Plotting for direction conditions
data.positioning.matched.accuracy_avg.long %>%
  group_by(direction) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  ggplot(aes(x = direction, y = mean_mean_accuracy, fill = direction)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci), width = 0.2) +
  labs(
    x = "Globe Direction",
    y = "Mean Accuracy",
    fill = "Globe Direction"
  ) +
  scale_fill_manual(
  values = c(diagonal = "#a6bddb",  
             horizontal = "#d0d1e6",
             vertical = "#b8e0d2")  
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(),
            legend.position = "none"  
  ) +
  coord_flip()

ggsave("Position_direction_bar.svg")

# Plotting for both Position Conditions and Technique
data.positioning.matched.accuracy_avg.long %>%
  group_by(positionCondition, distance, direction) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(positionCondition = case_when(
    positionCondition == "rotatingGlobe" ~ "Adaptive orientation",
    positionCondition == "nonRotatingGlobe" ~ "Static orientation",
    TRUE ~ as.character(positionCondition))) %>%
  ggplot(aes(x = positionCondition, y = mean_mean_accuracy, fill = positionCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci),
                width = 0.2) +
  facet_wrap(~ distance + direction) +
  labs(
    title = "Mean Match Accuracy by Positioning Technique, Distance, and Direction",
    x = "Positioning technique",
    y = "Mean accuracy",
    fill = "Positioning technique"
  ) +
  scale_fill_manual(
  values = c("Adaptive orientation" = "#a6bddb",  
               "Static orientation" = "#d0d1e6")  
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank()) +
  coord_flip()  


ggsave("Position_direction_distance_bar.svg")

# Boxplots for globe technique and conditions

data.positioning.matched.accuracy_avg.long %>%
  mutate(positionCondition = case_when(
    positionCondition == "rotatingGlobe" ~ "Adaptive\norientation",
    positionCondition == "nonRotatingGlobe" ~ "Static\norientation",
    TRUE ~ as.character(positionCondition))) %>%
  ggplot(aes(x = positionCondition, y = mean_accuracy)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  facet_wrap(~ distance + direction) + 
  labs(title = "Boxplots of Accuracy by\nPositioning Technique, Distance and Direction",
       x = "Positioning technique",
       y = "Match accuracy") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5)
  )

ggsave("Position_direction_distance_boxplot.svg")


data.positioning.matched.accuracy_avg.long %>%
  group_by(distance) %>%
  summarise(mean_accuracy = mean(mean_accuracy)) %>%
  pivot_wider(names_from = distance, values_from = mean_accuracy) %>%
  mutate(percent_diff = ((far - near) / near) * 100)

data.positioning.matched.accuracy_avg.long %>%
  group_by(direction) %>%
  summarise(mean_accuracy = mean(mean_accuracy)) %>%
  arrange(desc(mean_accuracy)) %>%
  mutate(percent_diff_from_lowest = (mean_accuracy - min(mean_accuracy)) / min(mean_accuracy) * 100)

```

```{r combined significant plots for positioning}

# ---- Plot 1: Distance (Accuracy) ----
plot_distance <- data.positioning.matched.accuracy_avg.long %>%
  group_by(distance) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  ggplot(aes(x = distance, y = mean_mean_accuracy, fill = distance)) +
  geom_col(width = 0.3) +  
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci), width = 0.2) +
  geom_text(aes(label = round(mean_mean_accuracy, 2)), hjust = -0.2, size = 3.5) +  # Value labels
  labs(x = "Globe Distance", y = "Mean Accuracy") +
  scale_fill_manual(values = c(near = "#a6bddb", far = "#d0d1e6")) +
  theme_minimal() +
  theme(axis.text.x = element_text(), legend.position = "none") +
  coord_flip()

# ---- Plot 2: Direction (Accuracy) ----
plot_direction <- data.positioning.matched.accuracy_avg.long %>%
  group_by(direction) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  ggplot(aes(x = direction, y = mean_mean_accuracy, fill = direction)) +
  geom_col(width = 0.5) +
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci), width = 0.2) +
  geom_text(aes(label = round(mean_mean_accuracy, 2)), hjust = -0.2, size = 3.5) +
  labs(x = "Globe Direction", y = "Mean Accuracy") +
  scale_fill_manual(values = c(diagonal = "#a6bddb", horizontal = "#d0d1e6", vertical = "#b8e0d2")) +
  theme_minimal() +
  theme(axis.text.x = element_text(), legend.position = "none") +
  coord_flip()

# ---- Plot 3: Direction (Task Completion Time) ----
plot_time <- data.positioning.taskCompletion_avg.long %>%
  group_by(direction) %>%
  summarise(
    mean_mean_time = mean(avg_completion_time, na.rm = TRUE),
    se = sd(avg_completion_time, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  ggplot(aes(x = direction, y = mean_mean_time, fill = direction)) +
  geom_col(width = 0.5) +
  geom_errorbar(aes(ymin = mean_mean_time - ci, ymax = mean_mean_time + ci), width = 0.2) +
  geom_text(aes(label = round(mean_mean_time, 2)), hjust = -0.2, size = 3.5) +
  labs(x = "Globe Direction", y = "Avg Completion Time") +
  scale_fill_manual(values = c(diagonal = "#a6bddb", horizontal = "#d0d1e6", vertical = "#b8e0d2")) +
  theme_minimal() +
  theme(axis.text.x = element_text(), legend.position = "none") +
  coord_flip()

# ---- Combine & Save ----
combined_plot <- plot_distance / plot_direction / plot_time

ggsave("Combined_three_plots_with_labels.svg", combined_plot, width = 10, height = 12)

```

##### Completion Time

###### Normality

```{r PositionStudy - Completion Time - Normality}

shapiro.test(data.positioning.time$Time)

hist(data.positioning.time$Time, breaks = 100,
     main = "Histogram of Positioning Gestures Task Completion Time", xlab = "Completion Time",
     col = "lightblue", xlim = c(0, 1))

plot(density(data.positioning.time$Time), 
     main = "Density Plot of Positioning Gestures Task Completion Time", xlab = "Completion Time",
     col = "blue", lwd = 2, xlim = c(0, 1))

```

###### Statistical Tests

```{r PositionStudy - Completion Time - Statistical Tests}

data.positioning.taskCompletion_avg.long <- data.positioning %>%
  group_by(UserID, positionCondition, TaskID, distance, direction) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  group_by(UserID, positionCondition, distance, direction) %>%
  summarise(
    avg_completion_time = mean(completion_time),
    .groups = "drop"
  )

data.positioning.taskCompletion_avg.art <- art(avg_completion_time ~ positionCondition * distance * direction + (1|UserID), data = data.positioning.taskCompletion_avg.long)

anova(data.positioning.taskCompletion_avg.art)

anova(data.positioning.taskCompletion_avg.art)

art_direction_time <- artlm(data.positioning.taskCompletion_avg.art, "direction")

# Pairwise of direction
emmeans_direction_time <- emmeans(art_direction_time, pairwise ~ direction)

emmeans_direction_time$contrasts
```

```{r}

# •	positionCondition had no significant effect on average task completion time:F(1, 99.00) = 0.61, p = 0.435
# •	distance also showed no significant effect:F(1, 100.62) = 1.75, p = 0.189
# •	direction showed a statistically significant main effect:F(2, 100.86) = 6.39, p = 0.0024 (**), suggesting direction influences how long tasks take
# •	The interaction between positionCondition and distance was not significant:F(1, 99.00) = 0.24, p = 0.624
# •	The interaction between positionCondition and direction was not significant:F(2, 99.00) = 0.50, p = 0.605
# •	The interaction between distance and direction was not significant:F(2, 100.71) = 0.57, p = 0.565
# •	The three-way interaction (positionCondition × distance × direction) was also not significant:F(2, 99.00) = 0.44, p = 0.647
# 
# Only direction had a statistically significant effect on average task completion time, indicating that the direction from which the task was approached meaningfully influenced how long participants took to complete it. Other factors—positionCondition, distance, and all interaction terms—did not have significant effects. This suggests that regardless of position or distance, direction alone may account for differences in task completion time in this context.

# Plotting for positioning technique
data.positioning.taskCompletion_avg.long %>%
  group_by(positionCondition) %>%
  summarise(
    mean_mean_time = mean(avg_completion_time, na.rm = TRUE),
    se = sd(avg_completion_time, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(positionCondition = case_when(
    positionCondition == "rotatingGlobe" ~ "Adaptive Orientation",
    positionCondition == "nonRotatingGlobe" ~ "Static Orientation",
    TRUE ~ as.character(positionCondition))) %>%
  ggplot(aes(x = positionCondition, y = mean_mean_time, fill = positionCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_time - ci, ymax = mean_mean_time + ci), width = 0.2) +
  labs(
    title = "Average Task Completion Time by Positioning Technique",
    x = "Positioning Technique",
    y = "Average Completion Time",
    fill = "Positioning Technique"
  ) +
  scale_fill_manual(
  values = c("Adaptive Orientation" = "#a6bddb",  
               "Static Orientation" = "#d0d1e6")  
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank())

# Plotting for distance factors
data.positioning.taskCompletion_avg.long %>%
  group_by(distance) %>%
  summarise(
    mean_mean_time = mean(avg_completion_time, na.rm = TRUE),
    se = sd(avg_completion_time, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  ggplot(aes(x = distance, y = mean_mean_time, fill = distance)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_time - ci, ymax = mean_mean_time + ci), width = 0.2) +
  labs(
    title = "Average Task Completion Time by Globe Distance Factors",
    x = "Globe Distance",
    y = "Average Completion Time",
    fill = "Globe Distance"
  ) +
  scale_fill_manual(
  values = c(near= "#a6bddb",  
               far = "#d0d1e6")  
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank())

# Plotting for direction factors
data.positioning.taskCompletion_avg.long %>%
  group_by(direction) %>%
  summarise(
    mean_mean_time = mean(avg_completion_time, na.rm = TRUE),
    se = sd(avg_completion_time, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  ggplot(aes(x = direction, y = mean_mean_time, fill = direction)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_time - ci, ymax = mean_mean_time + ci), width = 0.2) +
  labs(
    title = "Average Task Completion Time by Globe Direction",
    x = "Globe direction",
    y = "Average completion time",
    fill = "Globe direction"
  ) +
  scale_fill_manual(
  values = c(diagonal = "#a6bddb",  
            horizontal = "#d0d1e6",
             vertical = "#b8e0d2")  
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        plot.title = element_text(hjust = 0.5))

ggsave("positioning_direction_time.svg")

  # Plotting for both Position Factors and Technique
data.positioning.taskCompletion_avg.long %>%
  group_by(positionCondition, distance, direction) %>%
  summarise(
    mean_mean_time = mean(avg_completion_time, na.rm = TRUE),
    se = sd(avg_completion_time, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(positionCondition = case_when(
    positionCondition == "rotatingGlobe" ~ "Adaptive Orientation",
    positionCondition == "nonRotatingGlobe" ~ "Static Orientation",
    TRUE ~ as.character(positionCondition))) %>%
  ggplot(aes(x = positionCondition, y = mean_mean_time, fill = positionCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_time - ci, ymax = mean_mean_time + ci),
                width = 0.2) +
  facet_wrap(~ distance + direction) +
  labs(
    title = "Average Task Completion time\nby Globe Technique, Distance, and Direction",
    x = "Positioning Technique",
    y = "Average Completion Time",
    fill = "Positioning Technique"
  ) +
  scale_fill_manual(
  values = c("Adaptive Orientation" = "#a6bddb",  
               "Static Orientation" = "#d0d1e6")  
  ) +
  theme_minimal() +
    theme(
    axis.text.x = element_blank(),
    plot.title = element_text(hjust = 0.5)
  )

# Boxplots for Globe technique, Distance, and Direction Factors

data.positioning.taskCompletion_avg.long %>%
  mutate(positionCondition = case_when(
    positionCondition == "rotatingGlobe" ~ "Adaptive\nOrientation",
    positionCondition == "nonRotatingGlobe" ~ "Static\nOrientation",
    TRUE ~ as.character(positionCondition))) %>%
  ggplot(aes(x = positionCondition, y = avg_completion_time)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  facet_wrap(~ distance + direction, scales = "free_x") + 
  labs(title = "Boxplots of Average Task Completion Time\nby Technique, Distance, and Direction",
       x = "Technique",
       y = "Task Completion Time") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5)
  )


data.positioning.taskCompletion_avg.long %>%
  group_by(direction) %>%
  summarise(mean_time = mean(avg_completion_time)) %>%
  arrange(desc(mean_time)) %>%
  mutate(percent_diff_from_lowest = (mean_time - min(mean_time)) / min(mean_time) * 100)

```


##### Subjective Measures

###### Physical and Mental Exertion

```{r Subjective Measures - Physical and Mental Exertion}

data.positioning.combined_exertion <- data.positioning.paas %>%
  full_join(data.positioning.borg, by = c("UserID", "Technique")) %>%
  pivot_longer(
    cols = c(PAAS, BORGRPE),
    names_to = "Measure",
    values_to = "Score"
  ) %>%
  mutate(
    Measure = case_when(
      Measure == "PAAS" & Technique == "rotatingGlobe" ~ "PAAS_RG",
      Measure == "PAAS" & Technique == "nonRotatingGlobe" ~ "PAAS_NRG",
      Measure == "BORGRPE" & Technique == "rotatingGlobe" ~ "BORG_RG",
      Measure == "BORGRPE" & Technique == "nonRotatingGlobe" ~ "BORG_NRG",
      TRUE ~ Measure
    ),
    ExertionType = case_when(
      str_detect(Measure, "PAAS") ~ "Cognitive load",
      str_detect(Measure, "BORG") ~ "Physical exertion",
      TRUE ~ "Unknown"
    )
  ) %>%
  select(UserID, Technique, Measure, Score, ExertionType) %>%
  mutate(
    Technique = as.factor(Technique),
    ExertionType = as.factor(ExertionType)
  )

data.positioning.combined_exertion.art_anova <- art(Score ~ Technique * ExertionType + (1|UserID), data = data.positioning.combined_exertion)

data.positioning.combined_exertion.paas <- data.positioning.combined_exertion %>%
  filter(ExertionType == "Cognitive load")

data.positioning.combined_exertion.borg <- data.positioning.combined_exertion %>%
  filter(ExertionType == "Physical exertion")

data.positioning.combined_exertion.paas.art_anova <- art(
  Score ~ Technique + (1 | UserID),
  data = data.positioning.combined_exertion.paas
)

data.positioning.combined_exertion.borg.art_anova <- art(
  Score ~ Technique + (1|UserID), 
  data = data.positioning.combined_exertion.borg
  )

anova(data.positioning.combined_exertion.paas.art_anova)

anova(data.positioning.combined_exertion.borg.art_anova)

data.positioning.combined_exertion.paas %>%
  group_by(Technique) %>%
  summarise(mean_score = mean(Score, na.rm = TRUE)) %>%
  pivot_wider(names_from = Technique, values_from = mean_score) %>%
  mutate(
    `rotatingGlobe_mean` = `rotatingGlobe`,
    `nonRotatingGlobe_mean` = `nonRotatingGlobe`,
    percent_diff = (`rotatingGlobe` - `nonRotatingGlobe`) / `nonRotatingGlobe` * 100
  ) %>%
  select(rotatingGlobe_mean, nonRotatingGlobe_mean, percent_diff)

data.positioning.combined_exertion.borg %>%
  group_by(Technique) %>%
  summarise(mean_score = mean(Score, na.rm = TRUE)) %>%
  pivot_wider(names_from = Technique, values_from = mean_score) %>%
  mutate(
    `rotatingGlobe_mean` = `rotatingGlobe`,
    `nonRotatingGlobe_mean` = `nonRotatingGlobe`,
    percent_diff = (`rotatingGlobe` - `nonRotatingGlobe`) / `nonRotatingGlobe` * 100
  ) %>%
  select(rotatingGlobe_mean, nonRotatingGlobe_mean, percent_diff)

ggplot(data.positioning.combined_exertion, aes(x = Technique, y = Score, fill = ExertionType)) +
  geom_boxplot(width = 0.1, position = position_dodge(0.8)) +
  labs(
    x = "Positioning Technique",
    y = "Score",
    title = "Boxplots of Exertion Scores by Behavior and Exertion Type"
  ) +
  scale_fill_manual(
  values = c("Cognitive load" = "#a6bddb",  
            "Physical exertion" = "#d0d1e6")  
  ) +
  theme_minimal()

data.positioning.combined_exertion %>%
  group_by(Technique, ExertionType) %>%
  summarise(
    mean_score = mean(Score),
    sd = sd(Score),
    n = n(),
    ci = qt(0.975, df = n - 1) * sd / sqrt(n),
    .groups = "drop"
  ) %>%
  mutate(Technique = case_when(
    Technique == "rotatingGlobe" ~ "Adaptive Orientation",
    Technique == "nonRotatingGlobe" ~ "Static Orientation",
    TRUE ~ as.character(Technique))) %>%
  ggplot(aes(x = Technique, y = mean_score, fill = ExertionType)) +
  geom_col(position = position_dodge(width = 0.7), width = 0.6) +
  geom_errorbar(aes(ymin = mean_score - ci, ymax = mean_score + ci),
                position = position_dodge(width = 0.7), width = 0.2) +
  labs(
    x = "Positioning technique",
    y = "Mean score (95% CI)",
    fill = "Exertion type",
    title = "Mean score by Positioning Technique and Exertion Type"
  ) +
  scale_fill_manual(
  values = c("Cognitive load" = "#a6bddb",  
            "Physical exertion" = "#d0d1e6")  
  ) +
  theme_minimal()

data.positioning.combined_exertion %>%
  filter(ExertionType == "Cognitive load") %>%
  group_by(Technique) %>%
  summarise(
    mean_score = mean(Score),
    sd = sd(Score),
    n = n(),
    ci = qt(0.975, df = n - 1) * sd / sqrt(n),
    .groups = "drop"
  ) %>%
  mutate(Technique = case_when(
    Technique == "rotatingGlobe" ~ "Adaptive orientation",
    Technique == "nonRotatingGlobe" ~ "Static orientation",
    TRUE ~ as.character(Technique))) %>%
  ggplot(aes(x = Technique, y = mean_score, fill = Technique)) +
  geom_col(position = position_dodge(width = 0.7), width = 0.6) +
  geom_errorbar(aes(ymin = mean_score - ci, ymax = mean_score + ci),
                position = position_dodge(width = 0.7), width = 0.2) +
  labs(
    x = "Positioning technique",
    y = "Mean score (95% CI)",
    fill = "Positioning Technique",
    title = "Mean PAAS Score by Positioning Technique"
  ) +
  scale_fill_manual(
  values = c("Adaptive orientation" = "#a6bddb",  
            "Static orientation" = "#d0d1e6")  
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        plot.title = element_text(hjust = 0.5)) 


data.positioning.combined_exertion %>%
  filter(ExertionType == "Physical exertion") %>%
  group_by(Technique) %>%
  summarise(
    mean_score = mean(Score),
    sd = sd(Score),
    n = n(),
    ci = qt(0.975, df = n - 1) * sd / sqrt(n),
    .groups = "drop"
  ) %>%
  mutate(Technique = case_when(
    Technique == "rotatingGlobe" ~ "Adaptive orientation",
    Technique == "nonRotatingGlobe" ~ "Static orientation",
    TRUE ~ as.character(Technique))) %>%
  ggplot(aes(x = Technique, y = mean_score, fill = Technique)) +
  geom_col(position = position_dodge(width = 0.7), width = 0.6) +
  geom_errorbar(aes(ymin = mean_score - ci, ymax = mean_score + ci),
                position = position_dodge(width = 0.7), width = 0.2) +
  labs(
    x = "Positioning technique",
    y = "Mean score (95% CI)",
    fill = "Positioning Technique",
    title = "Mean BORG RPE Score by Positioning Technique"
  ) +
  scale_fill_manual(
  values = c("Adaptive orientation" = "#a6bddb",  
            "Static orientation" = "#d0d1e6")  
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        plot.title = element_text(hjust = 0.5)) 

data.positioning.combined_exertion %>%
  group_by(Technique, ExertionType) %>%
  summarise(mean_score = mean(Score))


```

###### Preference

```{r Positioning - Preference}

data.positioning.qualitative %>%
  count(Positioning_preference) %>%
  mutate(
    percent = n / sum(n),
    ncount = paste0(n, "\n", percent_format()(percent))
  ) %>%
  mutate(
    Preference = case_when(
    Positioning_preference == "adaptiveOrientation" ~ "Adaptive Orientation",
    Positioning_preference == "staticOrientation" ~ "Static Orientation",
    Positioning_preference == "noPreference" ~ "No Preference"
    )) %>%
  ggplot(aes(x = "", y = n, fill = Preference)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = ncount), position = position_stack(vjust = 0.5), size = 4) +
  labs(
    title = "Distribution of Positioning technique Preferences",
    fill = "Preference"
  ) +
  scale_fill_manual(
  values = c("Adaptive Orientation" = "#a6bddb",  
            "Static Orientation" = "#d0d1e6",
            "No Preference" = "#b8e0d2")  
  ) +
  theme_void()

data.positioning.qualitative %>%
  count(Positioning_preference) %>%
  mutate(
    Preference = case_when(
      Positioning_preference == "adaptiveOrientation" ~ "Adaptive orientation",
      Positioning_preference == "staticOrientation" ~ "Static orientation",
      Positioning_preference == "noPreference" ~ "No preference"
    )
  ) %>%
  ggplot(aes(x = n, y = reorder(Preference, n), fill = Preference)) +
  geom_col(width = 0.5) +  # Slimmer bars
  geom_text(aes(label = n), hjust = -0.9, size = 5, family = "Times New Roman") +  # Times font
  labs(
    x = NULL,
    y = NULL,
    fill = "Preference"
  ) +
  scale_fill_manual(
    values = c(
      "Adaptive orientation" = "gray60",
      "Static orientation" = "gray80",
      "No preference" = "gray90"
    )
  ) +
  theme_minimal(base_family = "Times New Roman") +  # Set Times New Roman globally
  theme(
    plot.title = element_blank(),  # Remove title
    legend.position = "none",
    plot.margin = margin(10, 30, 10, 10),
    axis.text.y = element_text(size = 18),
    axis.text.x = element_blank()
  ) +
  xlim(0, NA)

ggsave("Position_preference_bar.svg")

```

###### Comments

```{r Positioning - comments}

data.positioning.qualitative %>%
  mutate(
    Positioning_preference = case_when(
      Positioning_preference == "staticOrientation" ~ "Static Orientation",
      Positioning_preference == "adaptiveOrientation" ~ "Adaptive Orientation",
      Positioning_preference == "noPreference" ~ "No Preference",
      TRUE ~ Positioning_preference
    )
  ) %>%
  rename(
    "Participant ID" = UserID,
    "Positioning Preference" = Positioning_preference,
    "Positioning Feedback" = Positioning_feedback
  ) %>%
  kable(caption = "User Feedback Summary - Positioning", align = "c") %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = FALSE,
    position = "center"
  ) %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#f7f7f7") %>%
  scroll_box(width = "100%", height = "400px")


```

###### Summary

### Study: Rotating

#### Rotating Data Preparation

```{r Rotating Data Preparation}
data.rotating <- data %>%
  mutate(rotationCondition = if_else(oneHandedRotationGesture, "oneHanded", "twoHanded")) %>%
  select(-oneHandedRotationGesture) %>%
  inner_join(demographic, by = "UserID") %>%
  inner_join(rotation_OH, by = "UserID") %>%
  rename(
    PAAS_OH = Mentally_demanding,
    BORG_OH = Physically_demanding
  ) %>%
  mutate(
    PAAS_OH = as.numeric(str_extract(PAAS_OH, "\\d+(\\.\\d+)?")),
    BORG_OH = as.numeric(str_extract(BORG_OH, "\\d+(\\.\\d+)?"))
  ) %>%
  mutate(
    PAAS_OH = if_else(rotationCondition == "oneHanded", PAAS_OH, NA_real_),
    BORG_OH = if_else(rotationCondition == "oneHanded", BORG_OH, NA_real_)
  ) %>%
  inner_join(rotation_TH, by = "UserID") %>%
  rename(
    PAAS_TH = Mentally_demanding,
    BORG_TH = Physically_demanding
  ) %>%
  mutate(
    PAAS_TH = as.numeric(str_extract(PAAS_TH, "\\d+(\\.\\d+)?")),
    BORG_TH = as.numeric(str_extract(BORG_TH, "\\d+(\\.\\d+)?"))
  ) %>%
  mutate(
    PAAS_TH = if_else(rotationCondition == "twoHanded", PAAS_TH, NA_real_),
    BORG_TH = if_else(rotationCondition == "twoHanded", BORG_TH, NA_real_)
  ) %>%
  inner_join(rotation_preference, by = "UserID") %>%
  rename(
    technique_preference = Rotation_preference,
    technique_feedback = Rotation_feedback
  ) %>%
  mutate(
      technique_preference = case_when(
    str_detect(technique_preference, "One-handed") ~ "oneHandedPreference",
    str_detect(technique_preference, "Two-handed") ~ "twoHandedPreference",
    str_detect(technique_preference, "no preference") ~ "noPreference",
    TRUE ~ "unknown"
  )) %>%
  filter(Type == "rotationTask") %>%
  select(UserID, TaskID, ActionID, rotationCondition, complexity, Date, ActionStatus, main_rotation_x,
  main_rotation_y, main_rotation_z, main_rotation_w, target_rotation_x, target_rotation_y, target_rotation_z,
  target_rotation_w,match_accuracy_result, status, PAAS_OH, BORG_OH, PAAS_TH, BORG_TH, technique_preference, technique_feedback) %>%
  mutate(complexity = as.factor(complexity), 
         rotationCondition = as.factor(rotationCondition),
         status = as.factor(status),
         technique_preference = as.factor(technique_preference))

```

#### Rotation Task Study

##### Accuracy

###### Normality

```{r Rotation Task Study - Accuracy - Normality}

shapiro.test(data.rotating.accuracy$Accuracy)

hist(data.rotating.accuracy$Accuracy, breaks = 100,
     main = "Histogram of Rotating Gestures Accuracy", xlab = "Accuracy",
     col = "lightblue", xlim = c(0, 0.3))

plot(density(data.rotating.accuracy$Accuracy), 
     main = "Density Plot of Rotating Gestures Accuracy", xlab = "Accuracy",
     col = "blue", lwd = 2, xlim = c(0, 0.4))

```

Although the w value is close to 1, the p value is below 0.05 so we reject null hypothesis that the data is normally distributed
So, we cannot use one way ANOVA, instead, we use Wilcoxon signed-rank test

###### Statistical tests

```{r Rotation Task Study - Accuracy - Statistical Tests}
 
data.rotating.matched <- data.rotating %>%
  filter(status == "Matched")

data.rotating.matched.accuracy_avg.long <- data.rotating.matched %>%
  group_by(UserID, rotationCondition, complexity) %>%
  summarise(mean_accuracy = mean(match_accuracy_result, na.rm = TRUE), .groups = 'drop') 

data.rotating.matched.art <- art(mean_accuracy ~ rotationCondition * complexity + (1|UserID), data = data.rotating.matched.accuracy_avg.long)

anova(data.rotating.matched.art)

	# •	rotationCondition: F(1, 33) = 4.67, p = 0.038 Significant: rotation affects accuracy
	# •	complexity: F(1, 33) = 20.74, p < 0.001 Highly significant: complexity affects accuracy
	# •	rotationCondition × complexity: F(1, 33) = 0.25, p = 0.62 Not significant: no interaction effect

# The ART ANOVA revealed significant main effects of both rotation condition and complexity on accuracy. Rotation condition had a modest but significant effect (p = 0.038), while complexity showed a strong influence (p < 0.001). However, there was no significant interaction between rotation and complexity (p = 0.62), indicating that the effects of each factor on accuracy are independent and do not influence each other.

# Plotting for rotation technique
data.rotating.matched.accuracy_avg.long %>%
  group_by(rotationCondition) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(rotationCondition = case_when(
    rotationCondition == "oneHanded" ~ "One-Handed",
    rotationCondition == "twoHanded" ~ "Two-Handed",
    TRUE ~ as.character(rotationCondition))) %>%
  ggplot(aes(x = rotationCondition, y = mean_mean_accuracy, fill = rotationCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci), width = 0.2) +
  labs(
    title = "Mean Match Accuracy by Rotating Techniques",
    x = "Rotating technique",
    y = "Mean accuracy",
    fill = "Rotating technique"
  ) +
  scale_fill_manual(
    values = c("One-Handed" = "#a6bddb",  
               "Two-Handed" = "#d0d1e6")  
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text())

ggsave("Rotating_technique_accuracy.svg")

# Plotting for complexity factor
data.rotating.matched.accuracy_avg.long %>%
  group_by(complexity) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(
    complexity = case_when(
      complexity == "simple" ~ "Small Angle",
      complexity == "complex" ~ "Large Angle",
      TRUE ~ as.character(complexity))) %>%
  ggplot(aes(x = complexity, y = mean_mean_accuracy, fill = complexity)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci), width = 0.2) +
  labs(
    title = "Mean Match Accuracy by Rotating Technique and Rotation Angle",
    x = "Rotating techniques",
    y = "Mean accuracy",
    fill = "Rotation angle"
  ) +
  scale_fill_manual(
    values = c("Small Angle" = "#a6bddb",  
               "Large Angle" = "#d0d1e6")  
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text())

ggsave("Rotating_complexity_accuracy.svg")

# Plotting for both rotation factors and techniques
data.rotating.matched.accuracy_avg.long %>%
  group_by(rotationCondition, complexity) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(rotationCondition = case_when(
    rotationCondition == "oneHanded" ~ "One-Handed",
    rotationCondition == "twoHanded" ~ "Two-Handed",
    TRUE ~ as.character(rotationCondition))) %>%
  mutate(
    complexity = case_when(
      complexity == "simple" ~ "Small Angle",
      complexity == "complex" ~ "Large Angle",
      TRUE ~ as.character(complexity))) %>%
  ggplot(aes(x = rotationCondition, y = mean_mean_accuracy, fill = rotationCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci),
                width = 0.2) +
  facet_wrap(~ complexity) +
  labs(
    title = "Mean Match Accuracy by Rotating Technique and Rotation Angle",
    x = "Rotating technique",
    y = "Mean Accuracy",
    fill = "Rotating technique"
  ) +
  scale_fill_manual(
    values = c("One-Handed" = "#a6bddb",  
               "Two-Handed" = "#d0d1e6")  
  ) +
  theme_minimal() +
    theme(
    axis.text.x = element_blank()
  )

# Boxplots for rotation techniques and condition

data.rotating.matched.accuracy_avg.long %>%
    mutate(rotationCondition = case_when(
    rotationCondition == "oneHanded" ~ "One-Handed",
    rotationCondition == "twoHanded" ~ "Two-Handed",
    TRUE ~ as.character(rotationCondition))) %>%
  mutate(
    complexity = case_when(
      complexity == "simple" ~ "Small Angle",
      complexity == "complex" ~ "Large Angle",
      TRUE ~ as.character(complexity))) %>%
  ggplot(aes(x = rotationCondition, y = mean_accuracy)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  facet_wrap(~ complexity) + 
  labs(title = "Boxplots of Task Accuracy by Rotating Technique and Angle",
       x = "Rotating Technique",
       y = "Match Accuracy") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5)
  )

data.rotating.matched.accuracy_avg.long %>%
  group_by(rotationCondition) %>%
  summarise(mean_accuracy = mean(mean_accuracy)) %>%
  pivot_wider(names_from = rotationCondition, values_from = mean_accuracy) %>%
  mutate(percent_diff = ((twoHanded - oneHanded) / oneHanded) * 100)

data.rotating.matched.accuracy_avg.long %>%
  group_by(complexity) %>%
  summarise(mean_accuracy = mean(mean_accuracy)) %>%
  pivot_wider(names_from = complexity, values_from = mean_accuracy) %>%
  mutate(percent_diff = ((complex - simple) / simple) * 100)


data.rotating.matched.accuracy_avg.long
```

```{r rotating combined plots}

# ---- Plot 1: Accuracy by rotation technique ----
plot_rotate_acc_technique <- data.rotating.matched.accuracy_avg.long %>%
  group_by(rotationCondition) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(rotationCondition = case_when(
    rotationCondition == "oneHanded" ~ "One-Handed",
    rotationCondition == "twoHanded" ~ "Two-Handed",
    TRUE ~ as.character(rotationCondition)
  )) %>%
  ggplot(aes(x = rotationCondition, y = mean_mean_accuracy, fill = rotationCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci), width = 0.2) +
  labs(x = "Rotating technique", y = "Mean accuracy") +
  scale_fill_manual(values = c("One-Handed" = "#a6bddb", "Two-Handed" = "#d0d1e6")) +
  coord_flip() +
  ylim(0, 0.225)  +
  theme_minimal(base_family = "Times New Roman") +
  theme(legend.position = "none")

# ---- Plot 2: Accuracy by rotation angle ----
plot_rotate_acc_angle <- data.rotating.matched.accuracy_avg.long %>%
  group_by(complexity) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(complexity = case_when(
    complexity == "simple" ~ "Small Angle",
    complexity == "complex" ~ "Large Angle",
    TRUE ~ as.character(complexity)
  )) %>%
  ggplot(aes(x = complexity, y = mean_mean_accuracy, fill = complexity)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci), width = 0.2) +
  labs(x = "Rotation angle", y = "Mean accuracy") +
  scale_fill_manual(values = c("Small Angle" = "#a6bddb", "Large Angle" = "#d0d1e6")) +
  coord_flip() +
  ylim(0, 0.225) +
  theme_minimal(base_family = "Times New Roman") +
  theme(legend.position = "none")


# ---- Plot 3: Completion time by rotation technique ----
plot_rotate_time_technique <- data.rotating.taskCompletion_avg.long %>%
  group_by(rotationCondition) %>%
  summarise(
    mean_mean_time = mean(avg_completion_time, na.rm = TRUE),
    se = sd(avg_completion_time, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(rotationCondition = case_when(
    rotationCondition == "oneHanded" ~ "One-Handed",
    rotationCondition == "twoHanded" ~ "Two-Handed",
    TRUE ~ as.character(rotationCondition)
  )) %>%
  ggplot(aes(x = rotationCondition, y = mean_mean_time, fill = rotationCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_time - ci, ymax = mean_mean_time + ci), width = 0.2) +
  labs(x = "Rotating technique", y = "Avg completion time") +
  scale_fill_manual(values = c("One-Handed" = "#a6bddb", "Two-Handed" = "#d0d1e6")) +
  coord_flip() +
  ylim(0, 1)  +
  theme_minimal(base_family = "Times New Roman") +
  theme(legend.position = "none")

# ---- Plot 4: Completion time by rotation angle ----
plot_rotate_time_angle <- data.rotating.taskCompletion_avg.long %>%
  group_by(complexity) %>%
  summarise(
    mean_mean_time = mean(avg_completion_time, na.rm = TRUE),
    se = sd(avg_completion_time, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(complexity = case_when(
    complexity == "simple" ~ "Small Angle",
    complexity == "complex" ~ "Large Angle",
    TRUE ~ as.character(complexity)
  )) %>%
  ggplot(aes(x = complexity, y = mean_mean_time, fill = complexity)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_time - ci, ymax = mean_mean_time + ci), width = 0.2) +
  labs(x = "Rotation angle", y = "Avg completion time") +
  scale_fill_manual(values = c("Small Angle" = "#a6bddb", "Large Angle" = "#d0d1e6")) +
  coord_flip() +
  ylim(0, 01) +
  theme_minimal(base_family = "Times New Roman") +
  theme(legend.position = "none")

# ---- Combine all plots vertically ----
combined_rotation_plot <- plot_rotate_acc_technique /
                          plot_rotate_acc_angle /
                          plot_rotate_time_technique /
                          plot_rotate_time_angle

# ---- Save to file ----
ggsave("combined_rotation_plots_times_font.svg")

```


##### Completion Time

###### Normality

```{r Rotation Task Study - Completion Time - Normality}

shapiro.test(data.rotating.time$Time)

hist(data.rotating.time$Time, breaks = 100,
     main = "Histogram of Rotation Gestures Task Completion Time", xlab = "Completion Time",
     col = "lightblue", xlim = c(0, 2))

plot(density(data.rotating.time$Time), 
     main = "Density Plot of Rotation Gestures Task Completion Time", xlab = "Completion Time",
     col = "blue", lwd = 2, xlim = c(0, 2))

```

###### Statistical Tests

```{r Rotation Task Study - Completion Time - Statistical Tests}

data.rotating.taskCompletion_avg.long <- data.rotating %>%
  group_by(UserID, rotationCondition, complexity, TaskID) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  group_by(UserID, rotationCondition, complexity) %>%
  summarise(
    avg_completion_time = mean(completion_time),
    .groups = "drop"
  )

data.rotating.taskCompletion_avg.art <- art(avg_completion_time ~ rotationCondition * complexity + (1|UserID), data = data.rotating.taskCompletion_avg.long)

anova(data.rotating.taskCompletion_avg.art)

	# •	rotationCondition: F(1, 33) = 8.44, p = 0.0065 (**) Statistically significant — rotation has a clear effect on completion time
	# •	complexity: F(1, 33) = 37.75, p < 0.0001 (***) Statistically significant — complexity strongly affects completion time
	# •	rotationCondition × complexity: F(1, 33) = 2.36, p = 0.1344 Not significant — no evidence of interaction between rotation and complexity

# Plotting for rotating techniques
data.rotating.taskCompletion_avg.long %>%
  group_by(rotationCondition) %>%
  summarise(
    mean_mean_time = mean(avg_completion_time, na.rm = TRUE),
    se = sd(avg_completion_time, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(rotationCondition = case_when(
    rotationCondition == "oneHanded" ~ "One-Handed",
    rotationCondition == "twoHanded" ~ "Two-Handed",
    TRUE ~ as.character(rotationCondition))) %>%
  ggplot(aes(x = rotationCondition, y = mean_mean_time, fill = rotationCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_time - ci, ymax = mean_mean_time + ci), width = 0.2) +
  labs(
    title = "Average Task Completion Time by Rotating Techniques",
    x = "Globe rotation techniques",
    y = "Average completion time",
    fill = "Globe rotation techniques"
  ) +
  scale_fill_manual(
    values = c("One-Handed" = "#a6bddb",  
               "Two-Handed" = "#d0d1e6")  
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text())

ggsave("rotating_technique_time.svg")

# Plotting for complexity factors
data.rotating.taskCompletion_avg.long %>%
  group_by(complexity) %>%
  summarise(
    mean_mean_time = mean(avg_completion_time, na.rm = TRUE),
    se = sd(avg_completion_time, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(
    complexity = case_when(
      complexity == "simple" ~ "Small Angle",
      complexity == "complex" ~ "Large Angle",
      TRUE ~ as.character(complexity))) %>%
  ggplot(aes(x = complexity, y = mean_mean_time, fill = complexity)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_time - ci, ymax = mean_mean_time + ci), width = 0.2) +
  labs(
    title = "Average Task Completion Time by Rotation Angle",
    x = "Rotation Angle",
    y = "Average Completion Time",
    fill = "Rotation Angle"
  ) +
  scale_fill_manual(
    values = c("Small Angle" = "#a6bddb",  
               "Large Angle" = "#d0d1e6")  
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank())

ggsave("rotating_complexity_time.svg")

# Plotting for both rotation Factors and Technique
data.rotating.taskCompletion_avg.long %>%
  group_by(rotationCondition, complexity) %>%
  summarise(
    mean_mean_time = mean(avg_completion_time, na.rm = TRUE),
    se = sd(avg_completion_time, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(rotationCondition = case_when(
    rotationCondition == "oneHanded" ~ "One-Handed",
    rotationCondition == "twoHanded" ~ "Two-Handed",
    TRUE ~ as.character(rotationCondition))) %>%
  mutate(
    complexity = case_when(
      complexity == "simple" ~ "Small Angle",
      complexity == "complex" ~ "Large Angle",
      TRUE ~ as.character(complexity))) %>%
  ggplot(aes(x = rotationCondition, y = mean_mean_time, fill = rotationCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_time - ci, ymax = mean_mean_time + ci),
                width = 0.2) +
  facet_wrap(~ complexity) +
  labs(
    title = "Average Task Completion Time by Rotating Technique and Rotation Angle",
    x = "Rotating technique",
    y = "Average completion time",
    fill = "Rotating technique"
  ) +
  scale_fill_manual(
    values = c("One-Handed" = "#a6bddb",  
               "Two-Handed" = "#d0d1e6")  
  ) +
  theme_minimal() +
    theme(
    axis.text.x = element_blank()
  )

# Boxplots for rotation techniques and complexity factors

data.rotating.taskCompletion_avg.long %>%
  mutate(rotationCondition = case_when(
    rotationCondition == "oneHanded" ~ "One-Handed",
    rotationCondition == "twoHanded" ~ "Two-Handed",
    TRUE ~ as.character(rotationCondition))) %>%
  mutate(
    complexity = case_when(
      complexity == "simple" ~ "Small Angle",
      complexity == "complex" ~ "Large Angle",
      TRUE ~ as.character(complexity))) %>%
  ggplot(aes(x = rotationCondition, y = avg_completion_time)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  facet_wrap(~ complexity) +
  labs(title = "Boxplots of Average Task Completion Time\nby Rotating Technique and Rotation Angle",
       x = "Technique",
       y = "Task Completion Time") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5)
  )

data.rotating.taskCompletion_avg.long %>%
  group_by(rotationCondition) %>%
  summarise(avg_completion_time = mean(avg_completion_time)) %>%
  pivot_wider(names_from = rotationCondition, values_from = avg_completion_time) %>%
  mutate(percent_diff = ((twoHanded - oneHanded) / oneHanded) * 100)

data.rotating.taskCompletion_avg.long %>%
  group_by(complexity) %>%
  summarise(avg_completion_time = mean(avg_completion_time)) %>%
  pivot_wider(names_from = complexity, values_from = avg_completion_time) %>%
  mutate(percent_diff = ((complex - simple) / simple) * 100)



```


##### Subjective Measures

###### Physical and Mental Exertion

```{r Rotation - Physical and Mental Exertion}

data.rotating.combined_exertion <- data.rotating.paas %>%
  full_join(data.rotating.borg, by = c("UserID", "Technique")) %>%
  pivot_longer(
    cols = c(PAAS, BORGRPE),
    names_to = "Measure",
    values_to = "Score"
  ) %>%
  mutate(
    Measure = case_when(
      Measure == "PAAS" & Technique == "oneHanded" ~ "PAAS_OH",
      Measure == "PAAS" & Technique == "twoHanded" ~ "PAAS_TH",
      Measure == "BORGRPE" & Technique == "oneHanded" ~ "BORG_OH",
      Measure == "BORGRPE" & Technique == "twoHanded" ~ "BORG_TH",
      TRUE ~ Measure
    ),
    ExertionType = case_when(
      str_detect(Measure, "PAAS") ~ "Cognitive load",
      str_detect(Measure, "BORG") ~ "Physical exertion",
      TRUE ~ "Unknown"
    )
  ) %>%
  select(UserID, Technique, Measure, Score, ExertionType) %>%
  mutate(
    Technique = as.factor(Technique),
    ExertionType = as.factor(ExertionType)
  )

data.rotating.combined_exertion.art_anova <- art(Score ~ Technique * ExertionType + (1|UserID), data = data.rotating.combined_exertion)

anova(data.rotating.combined_exertion.art_anova)

data.rotating.combined_exertion.paas <- data.rotating.combined_exertion %>%
  filter(ExertionType == "Cognitive load")

data.rotating.combined_exertion.borg <- data.rotating.combined_exertion %>%
  filter(ExertionType == "Physical exertion")

data.rotating.combined_exertion.paas.art_anova <- art(
  Score ~ Technique + (1 | UserID),
  data = data.rotating.combined_exertion.paas
)

data.rotating.combined_exertion.borg.art_anova <- art(
  Score ~ Technique + (1|UserID), 
  data = data.rotating.combined_exertion.borg
  )

anova(data.rotating.combined_exertion.paas.art_anova)

anova(data.rotating.combined_exertion.borg.art_anova)


data.rotating.combined_exertion.paas %>%
  group_by(Technique) %>%
  summarise(mean_score = mean(Score, na.rm = TRUE)) %>%
  tidyr::pivot_wider(names_from = Technique, values_from = mean_score) %>%
  mutate(
    twoHanded_mean = twoHanded,
    oneHanded_mean = oneHanded,
    percent_diff = (twoHanded - oneHanded) / oneHanded * 100
  ) %>%
  select(twoHanded_mean, oneHanded_mean, percent_diff)

data.rotating.combined_exertion.borg %>%
  group_by(Technique) %>%
  summarise(mean_score = mean(Score, na.rm = TRUE)) %>%
  tidyr::pivot_wider(names_from = Technique, values_from = mean_score) %>%
  mutate(
    twoHanded_mean = twoHanded,
    oneHanded_mean = oneHanded,
    percent_diff = (twoHanded - oneHanded) / oneHanded * 100
  ) %>%
  select(twoHanded_mean, oneHanded_mean, percent_diff)


# 	•	Main effect of rotationCondition: F(1, 33) = 4.28, p = 0.0466 This is statistically significant at the 0.05 level, indicating that rotating vs non-rotating globe conditions have a meaningful impact on participants’ perceived exertion scores (cognitive or physical).
#	  •	Main effect of ExertionType: F(1, 33) = 20.75, p < 0.001 This is highly significant,  showing a strong difference between cognitive load (PAAS) and physical exertion (BORG) scores, regardless of the globe rotation condition.
#  	•	Interaction effect (rotationCondition × ExertionType): F(1, 33) = 0.016, p = 0.8990 Not significant. Suggesting that the difference between cognitive and physical exertion is consistent across both rotation conditions. The type of exertion does not change depending on whether the globe was rotating or not.
# Both rotation condition and exertion type have independent effects on perceived exertion. Participants reported different exertion levels between rotating and non-rotating globes, and also between cognitive and physical demands. However, there is no interaction, meaning the relative difference between PAAS and BORG remains stable across rotation types.

ggplot(data.rotating.combined_exertion, aes(x = Technique, y = Score, fill = ExertionType)) +
  geom_boxplot(width = 0.1, position = position_dodge(0.8)) +
  labs(
    x = "Rotation Condition",
    y = "Score",
    title = "Distribution of Scores by Technique and Exertion Type"
  ) +
  scale_fill_manual(
  values = c("Cognitive load" = "#a6bddb",  
            "Physical exertion" = "#d0d1e6")  
  ) +
  theme_minimal()

data.rotating.combined_exertion %>%
  group_by(Technique, ExertionType) %>%
  summarise(
    mean_score = mean(Score),
    sd = sd(Score),
    n = n(),
    ci = qt(0.975, df = n - 1) * sd / sqrt(n),
    .groups = "drop"
  ) %>%
  mutate(Technique = case_when(
    Technique == "oneHanded" ~ "One Handed",
    Technique == "twoHanded" ~ "Two Handed",
    TRUE ~ as.character(Technique))) %>%
  ggplot(aes(x = Technique, y = mean_score, fill = ExertionType)) +
  geom_col(position = position_dodge(width = 0.7), width = 0.6) +
  geom_errorbar(aes(ymin = mean_score - ci, ymax = mean_score + ci),
                position = position_dodge(width = 0.7), width = 0.2) +
  labs(
    x = "Rotation Technique",
    y = "Mean Score (95% CI)",
    fill = "Exertion Type",
    title = "Mean Score by Position Condition and Exertion Type"
  ) +
  scale_fill_manual(
  values = c("Cognitive load" = "#a6bddb",  
            "Physical exertion" = "#d0d1e6")  
  ) +
  theme_minimal()

data.rotating.combined_exertion %>%
  filter(ExertionType == "Cognitive load") %>%
  group_by(Technique) %>%
  summarise(
    mean_score = mean(Score),
    sd = sd(Score),
    n = n(),
    ci = qt(0.975, df = n - 1) * sd / sqrt(n),
    .groups = "drop"
  ) %>%
  mutate(Technique = case_when(
    Technique == "oneHanded" ~ "One-Handed",
    Technique == "twoHanded" ~ "Two-Handed",
    TRUE ~ as.character(Technique))) %>%
  ggplot(aes(x = Technique, y = mean_score, fill = Technique)) +
  geom_col(position = position_dodge(width = 0.7), width = 0.6) +
  geom_errorbar(aes(ymin = mean_score - ci, ymax = mean_score + ci),
                position = position_dodge(width = 0.7), width = 0.2) +
  labs(
    x = "Rotating technique",
    y = "Mean score (95% CI)",
    fill = "Rotating Technique",
    title = "Mean PAAS Score by Rotating Technique"
  ) +
  scale_fill_manual(
  values = c("One-Handed" = "#a6bddb",  
            "Two-Handed" = "#d0d1e6")  
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        plot.title = element_text(hjust = 0.5)) 


data.rotating.combined_exertion %>%
  filter(ExertionType == "Physical exertion") %>%
  group_by(Technique) %>%
  summarise(
    mean_score = mean(Score),
    sd = sd(Score),
    n = n(),
    ci = qt(0.975, df = n - 1) * sd / sqrt(n),
    .groups = "drop"
  ) %>%
  mutate(Technique = case_when(
    Technique == "oneHanded" ~ "One-Handed",
    Technique == "twoHanded" ~ "Two-Handed",
    TRUE ~ as.character(Technique))) %>%
  ggplot(aes(x = Technique, y = mean_score, fill = Technique)) +
  geom_col(position = position_dodge(width = 0.7), width = 0.6) +
  geom_errorbar(aes(ymin = mean_score - ci, ymax = mean_score + ci),
                position = position_dodge(width = 0.7), width = 0.2) +
  labs(
    x = "Rotating technique",
    y = "Mean score (95% CI)",
    fill = "Rotating Technique",
    title = "Mean BORG RPE Score by Rotating Technique"
  ) +
  scale_fill_manual(
  values = c("One-Handed" = "#a6bddb",  
            "Two-Handed" = "#d0d1e6")  
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        plot.title = element_text(hjust = 0.5)) 

data.rotating.combined_exertion %>%
  group_by(Technique, ExertionType) %>%
  summarise(mean_score = mean(Score))

```

###### Preference

```{r Rotating - Preference}

data.rotating.qualitative %>%
  count(Rotation_preference) %>%
  mutate(
    percent = n / sum(n),
    ncount = paste0(n, "\n", percent_format()(percent))
  ) %>%
  mutate(
    Preference = case_when(
    Rotation_preference == "oneHandedPreference" ~ "One Handed Preference",
    Rotation_preference == "twoHandedPreference" ~ "Two Handed Preference",
    Rotation_preference == "noPreference" ~ "No Preference"
    )) %>%
  ggplot(aes(x = "", y = n, fill = Preference)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = ncount), position = position_stack(vjust = 0.5), size = 4) +
  labs(
    title = "Distribution of Rotation Technique Preferences",
    fill = "Preference"
  ) +
  scale_fill_manual(
  values = c("One Handed Preference" = "#a6bddb",  
            "Two Handed Preference" = "#d0d1e6",
            "No Preference" = "#b8e0d2")  
  ) +
  theme_void()

data.rotating.qualitative %>%
  count(Rotation_preference) %>%
  mutate(
    Preference = case_when(
      Rotation_preference == "oneHandedPreference" ~ "One Handed Preference",
      Rotation_preference == "twoHandedPreference" ~ "Two Handed Preference",
      Rotation_preference == "noPreference" ~ "No preference"
    )
  ) %>%
  ggplot(aes(x = n, y = reorder(Preference, n), fill = Preference)) +
  geom_col(width = 0.4) +  
  geom_text(aes(label = n), hjust = -0.9, size = 5, family = "Times New Roman") +
  labs(
    x = NULL,
    y = NULL,
    fill = "Preference"
  ) +
  scale_fill_manual(
    values = c(
      "One Handed Preference" = "#a6bddb",
      "Two Handed Preference" = "#d0d1e6",
      "No preference" = "#b8e0d2"
    )
  ) +
  scale_x_continuous(
    limits = c(0, 9),
    breaks = 0:9
  ) +
  theme_minimal(base_family = "Times New Roman") +
  theme(
    plot.title = element_text(hjust = 0.5, size = 18),
    legend.position = "none",
    plot.margin = margin(10, 60, 10, 10),
    axis.text.y = element_text(size = 18),
    axis.text.x = element_blank()
  )

ggsave("rotating_preference.svg")


```


###### Comments


```{r Rotating - Comments}

data.rotating.qualitative %>%
  mutate(
    Rotation_preference = case_when(
      Rotation_preference == "oneHandedPreference" ~ "One-handed Rotation Gesture",
      Rotation_preference == "twoHandedPreference" ~ "Two-handed Rotation Gesture",
      Rotation_preference == "noPreference" ~ "No Preference",
      TRUE ~ Rotation_preference
    )
  ) %>%
  rename(
    "Participant ID" = UserID,
    "Rotating Preference" = Rotation_preference,
    "Rotating Feedback" = Rotation_feedback
  ) %>%
  kable(caption = "User Feedback Summary - Rotating", align = "c") %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = FALSE,
    position = "center"
  ) %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#f7f7f7") %>%
  scroll_box(width = "100%", height = "400px")

```

###### Summary

### Study: Scale

#### Scale Data Preparation

```{r Scale Data Preparation}

data.scale <- data %>%
  mutate(scaleCondition = if_else(moveGlobeWhileScaling, "movingGlobe", "nonMovingGlobe")) %>%
  select(-moveGlobeWhileScaling) %>%
  inner_join(demographic, by = "UserID") %>%
  inner_join(scale_MG, by = "UserID") %>%
    rename(
    PAAS_MG = Mentally_demanding,
    BORG_MG = Physically_demanding
  ) %>%
  mutate(
    PAAS_MG = as.numeric(str_extract(PAAS_MG, "\\d+(\\.\\d+)?")),
    BORG_MG = as.numeric(str_extract(BORG_MG, "\\d+(\\.\\d+)?"))
  ) %>%
  mutate(
    PAAS_MG = if_else(scaleCondition == "movingGlobe", PAAS_MG, NA_real_),
    BORG_MG = if_else(scaleCondition == "movingGlobe", BORG_MG, NA_real_)
  ) %>%
  inner_join(scale_NMG, by = "UserID") %>%
  rename(
    PAAS_NMG = Mentally_demanding,
    BORG_NMG = Physically_demanding
  ) %>%
  mutate(
    PAAS_NMG = as.numeric(str_extract(PAAS_NMG, "\\d+(\\.\\d+)?")),
    BORG_NMG = as.numeric(str_extract(BORG_NMG, "\\d+(\\.\\d+)?"))
  ) %>%
  mutate(
    PAAS_NMG = if_else(scaleCondition == "nonMovingGlobe", PAAS_NMG, NA_real_),
    BORG_NMG = if_else(scaleCondition == "nonMovingGlobe", BORG_NMG, NA_real_)
  ) %>%
  inner_join(scale_preference, by = "UserID") %>%
  rename(
    technique_preference = Scale_preference,
    technique_feedback = Scale_feedback
  ) %>%
  mutate(
    technique_preference = case_when(
    str_detect(technique_preference, "Maintain distance") ~ "maintainDistance",
    str_detect(technique_preference, "Maintain globe") ~ "maintainGlobe",
    str_detect(technique_preference, "no preference") ~ "noPreference",
    TRUE ~ "unknown"
  )) %>%
  filter(Type == "scaleTask") %>%
  select(UserID, TaskID, ActionID, scaleCondition, zoomDirection, Date, ActionStatus, main_scale_x,
  main_scale_y, main_scale_z, target_scale_x, target_scale_y, target_scale_z, match_accuracy_result, status,
  PAAS_MG, BORG_MG, PAAS_NMG, BORG_NMG, technique_preference, technique_feedback) %>%
  mutate(zoomDirection = as.factor(zoomDirection), 
         scaleCondition = as.factor(scaleCondition),
         status = as.factor(status),
         technique_preference = as.factor(technique_preference))

```

#### Scale Task Study

##### Accuracy

###### Normality

```{r Scale Task Study - Accuracy - Normality}

shapiro.test(data.scale.accuracy$Accuracy)

hist(data.scale.accuracy$Accuracy, breaks = 100,
     main = "Histogram of Scaling Gestures Accuracy", xlab = "Accuracy",
     col = "lightblue", xlim = c(0, 0.12))

plot(density(data.scale.accuracy$Accuracy), 
     main = "Density Plot of Scaling Gestures Accuracy", xlab = "Accuracy",
     col = "blue", lwd = 2, xlim = c(0, 0.15))

# Although the w value is close to 1, the p value is below 0.05 so we reject null hypothesis that the data is normally distributed
# So, we cannot use one way ANOVA, instead, we use Wilcoxon signed-rank test
```

###### Statistical tests 

```{r Scale Task Study - Accuracy - Statistical Tests}

data.scale.matched <- data.scale %>%
  filter(status == "Matched")

data.scale.matched.accuracy_avg.long <- data.scale.matched %>%
  group_by(UserID, scaleCondition, zoomDirection) %>%
  summarise(mean_accuracy = mean(match_accuracy_result, na.rm = TRUE), .groups = 'drop')

data.scale.matched.art <- art(mean_accuracy ~ scaleCondition * zoomDirection + (1|UserID), data = data.scale.matched.accuracy_avg.long)

anova(data.scale.matched.art)

# •	The main effect of scaleCondition on mean accuracy was not significant, F(1, 33) = 0.55, p = 0.464.
# •	The main effect of zoomDirection was also not significant, F(1, 33) = 0.51, p = 0.478.
# •	The interaction between scaleCondition and zoomDirection was not significant either, F(1, 33) = 0.95, p = 0.336.

# There were no statistically significant effects of either scale condition, zoom direction, or their interaction on mean accuracy. This suggests that participants’ accuracy was not influenced by how the globe was scaled or zoomed, nor by the combination of these two factors.

# Plotting for scale techniques
data.scale.matched.accuracy_avg.long %>%
  group_by(scaleCondition) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(scaleCondition = case_when(
    scaleCondition == "movingGlobe" ~ "Moving Globe",
    scaleCondition == "nonMovingGlobe" ~ "Non Moving Globe",
    TRUE ~ as.character(scaleCondition))) %>%
  ggplot(aes(x = scaleCondition, y = mean_mean_accuracy, fill = scaleCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci), width = 0.2) +
  labs(
    title = "Mean Match Accuracy by Globe technique",
    x = "Scaling technique",
    y = "Mean Accuracy",
    fill = "Scaling technique"
  ) +
  scale_fill_manual(
  values = c("Moving Globe" = "#a6bddb",  
           "Non Moving Globe" = "#d0d1e6") 
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank())

# Plotting for zoom direction factors
data.scale.matched.accuracy_avg.long %>%
  group_by(zoomDirection) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(
    zoomDirection = case_when(
      zoomDirection == "smallToLarge" ~ "Small to Large",
      zoomDirection == "largeToSmall" ~ "Large to Small",
      TRUE ~ as.character(zoomDirection))) %>%
  ggplot(aes(x = zoomDirection, y = mean_mean_accuracy, fill = zoomDirection)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci), width = 0.2) +
  labs(
    title = "Mean Match Accuracy by Globe Zoom Direction Factors",
    x = "Zoom direction",
    y = "Mean Accuracy",
    fill = "Globe Direction"
  ) +
  scale_fill_manual(
  values = c("Small to Large" = "#a6bddb",  
           "Large to Small" = "#d0d1e6") 
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank())

# Plotting for both scale Conditions and techniques
data.scale.matched.accuracy_avg.long %>%
  group_by(scaleCondition, zoomDirection) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(scaleCondition = case_when(
    scaleCondition == "movingGlobe" ~ "Moving Globe",
    scaleCondition == "nonMovingGlobe" ~ "Non Moving Globe",
    TRUE ~ as.character(scaleCondition))) %>%
  mutate(
    zoomDirection = case_when(
      zoomDirection == "smallToLarge" ~ "Small to Large",
      zoomDirection == "largeToSmall" ~ "Large to Small",
      TRUE ~ as.character(zoomDirection))) %>%
  ggplot(aes(x = scaleCondition, y = mean_mean_accuracy, fill = scaleCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci),
                width = 0.2) +
  facet_wrap(~ zoomDirection) +
  labs(
    title = "Mean Match Accuracy by Globe technique, and Zoom Direction Factors",
    x = "Globe scale technique",
    y = "Mean Accuracy",
    fill = "Globe scale technique"
  ) +
  scale_fill_manual(
  values = c("Moving Globe" = "#a6bddb",  
           "Non Moving Globe" = "#d0d1e6") 
  ) +
  theme_minimal() +
    theme(
    axis.text.x = element_blank()
  )

# Boxplots for globe technique and conditions

data.scale.matched.accuracy_avg.long %>%
    mutate(scaleCondition = case_when(
    scaleCondition == "movingGlobe" ~ "Moving Globe",
    scaleCondition == "nonMovingGlobe" ~ "Non Moving Globe",
    TRUE ~ as.character(scaleCondition))) %>%
  mutate(
    zoomDirection = case_when(
      zoomDirection == "smallToLarge" ~ "Small to Large",
      zoomDirection == "largeToSmall" ~ "Large to Small",
      TRUE ~ as.character(zoomDirection))) %>%
  ggplot(aes(x = scaleCondition, y = mean_accuracy)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  facet_wrap(~ zoomDirection) + 
  labs(title = "Boxplots of Accuracy by Globe Movement technique",
       x = "technique",
       y = "Match Accuracy") +
  scale_fill_manual(
  values = c("Moving Globe" = "#a6bddb",  
           "Non Moving Globe" = "#d0d1e6") 
  ) +
  theme_minimal()
```

##### Completion Time

###### Normality

```{r Scale Task Study - Completion Time - Normality}

shapiro.test(data.scale.time$Time)

hist(data.scale.time$Time, breaks = 100,
     main = "Histogram of Scale Gestures Task Completion Time", xlab = "Completion Time",
     col = "lightblue", xlim = c(0, 0.8))

plot(density(data.scale.time$Time), 
     main = "Density Plot of Scale Gestures Task Completion Time", xlab = "Completion Time",
     col = "blue", lwd = 2, xlim = c(0, 0.8))

```

###### Statistical Tests

```{r Scale Task Study - Completion Time - Statistical Tests}

data.scale.taskCompletion_avg.long <- data.scale %>%
  group_by(UserID, scaleCondition, TaskID, zoomDirection) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  group_by(UserID, scaleCondition, zoomDirection) %>%
  summarise(
    avg_completion_time = mean(completion_time),
    .groups = "drop"
  ) 

data.scale.taskCompletion.art <- art(avg_completion_time ~ scaleCondition * zoomDirection + (1|UserID), data = data.scale.taskCompletion_avg.long)

anova(data.scale.taskCompletion.art)

# The aligned rank transform ANOVA (ART ANOVA) revealed a significant main effect of zoom direction on average completion time, F(1, 33) = 4.97, p = .033, indicating that the direction of zooming (i.e., scaling up or down) influenced how long participants took to complete the task. However, there was no significant main effect of scale condition, F(1, 33) = 0.28, p = .603, and no significant interaction between scale condition and zoom direction, F(1, 33) = 0.21, p = .652. These results suggest that while zoom direction independently affected completion time, the scale condition and the interaction between the two did not meaningfully impact task duration.


# Plotting for scale technique
data.scale.taskCompletion_avg.long %>%
  group_by(scaleCondition) %>%
  summarise(
    mean_mean_time = mean(avg_completion_time, na.rm = TRUE),
    se = sd(avg_completion_time, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(scaleCondition = case_when(
    scaleCondition == "movingGlobe" ~ "Moving Globe",
    scaleCondition == "nonMovingGlobe" ~ "Non Moving Globe",
    TRUE ~ as.character(scaleCondition))) %>%
  ggplot(aes(x = scaleCondition, y = mean_mean_time, fill = scaleCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_time - ci, ymax = mean_mean_time + ci), width = 0.2) +
  labs(
    title = "Average Task Completion Time by Scaling Technique",
    x = "Globe technique",
    y = "Average Completion Time",
    fill = "Globe technique"
  ) +
  scale_fill_manual(
  values = c("Moving Globe" = "#a6bddb",  
           "Non Moving Globe" = "#d0d1e6") 
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank())

# Plotting for globe zoom direction factors
data.scale.taskCompletion_avg.long %>%
  group_by(zoomDirection) %>%
  summarise(
    mean_mean_time = mean(avg_completion_time, na.rm = TRUE),
    se = sd(avg_completion_time, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(
    zoomDirection = case_when(
      zoomDirection == "smallToLarge" ~ "Small to Large",
      zoomDirection == "largeToSmall" ~ "Large to Small",
      TRUE ~ as.character(zoomDirection)
    )
  ) %>%
  ggplot(aes(x = zoomDirection, y = mean_mean_time, fill = zoomDirection)) +
  geom_col(width = 0.5) +  # Slim bar
  geom_errorbar(aes(ymin = mean_mean_time - ci, ymax = mean_mean_time + ci), width = 0.2) +
  geom_text(aes(label = round(mean_mean_time, 2)), hjust = -0.9, size = 5, family = "Times New Roman") +
  labs(
    x = "Zoom direction",
    y = "Average Completion Time",
    fill = "Zoom Direction"
  ) +
  scale_fill_manual(
    values = c(
      "Small to Large" = "gray60",
      "Large to Small" = "gray80"
    )
  ) +
  theme_minimal(base_family = "Times New Roman") +
  theme(
    plot.title = element_blank(),
    legend.position = "none",
    plot.margin = margin(10, 30, 10, 10),
    axis.text.y = element_text(size = 18),
    axis.text.x = element_text()
  ) +
  coord_flip()

# Save output
ggsave("scaling_direction_time.svg")

# Plotting for both Position Factors and Technique
data.scale.taskCompletion_avg.long %>%
  group_by(scaleCondition, zoomDirection) %>%
  summarise(
    mean_mean_time = mean(avg_completion_time, na.rm = TRUE),
    se = sd(avg_completion_time, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(scaleCondition = case_when(
    scaleCondition == "movingGlobe" ~ "Maintain distance",
    scaleCondition == "nonMovingGlobe" ~ "Maintain position",
    TRUE ~ as.character(scaleCondition))) %>%
  mutate(
    zoomDirection = case_when(
      zoomDirection == "smallToLarge" ~ "Small to Large",
      zoomDirection == "largeToSmall" ~ "Large to Small",
      TRUE ~ as.character(zoomDirection))) %>%
  ggplot(aes(x = zoomDirection, y = mean_mean_time, fill = zoomDirection)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_time - ci, ymax = mean_mean_time + ci),
                width = 0.2) +
  facet_wrap(~ scaleCondition) +
  labs(
    title = "Average Task Completion Time by Scaling Technique, and Zoom Direction",
    x = "Zoom direction",
    y = "Average Completion Time",
    fill = "Zoom Direction"
  ) +
  scale_fill_manual(
  values = c("Small to Large" = "#a6bddb",  
           "Large to Small" = "#d0d1e6") 
  ) +
  theme_minimal() +
    theme(
    axis.text.x = element_blank()
  )

# Boxplots for Task Completion Time and Zoom Direction Factors

data.scale.taskCompletion_avg.long %>%
    mutate(scaleCondition = case_when(
    scaleCondition == "movingGlobe" ~ "Maintain distance",
    scaleCondition == "nonMovingGlobe" ~ "Maintain position",
    TRUE ~ as.character(scaleCondition))) %>%
  mutate(
    zoomDirection = case_when(
      zoomDirection == "smallToLarge" ~ "Small to Large",
      zoomDirection == "largeToSmall" ~ "Large to Small",
      TRUE ~ as.character(zoomDirection))) %>%
  ggplot(aes(x = zoomDirection, y = avg_completion_time)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  facet_wrap(~ scaleCondition) + 
  labs(title = "Boxplots of Average Task Completion Time\nby Scaling Technique and Zoom Direction Factors",
       x = "Zoom direction",
       y = "Task completion time") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5)
  )

data.scale.taskCompletion_avg.long %>%
  group_by(zoomDirection) %>%
  summarise(avg_completion_time = mean(avg_completion_time)) %>%
  pivot_wider(names_from = zoomDirection, values_from = avg_completion_time) %>%
  mutate(percent_diff = ((largeToSmall - smallToLarge) / smallToLarge) * 100)

data.scale.taskCompletion_avg.long %>%
  group_by(zoomDirection) %>%
  summarise(mean_time = mean(avg_completion_time)) %>%
  arrange(desc(mean_time)) %>%
  mutate(percent_diff_from_lowest = (mean_time - min(mean_time)) / min(mean_time) * 100)
```


##### Subjective Measures

###### Physical and Mental Exertion

```{r Scale - Physical and Mental Exertion}

data.scale.combined_exertion <- data.scale.paas %>%
  full_join(data.scale.borg, by = c("UserID", "Technique")) %>%
  pivot_longer(
    cols = c(PAAS, BORGRPE),
    names_to = "Measure",
    values_to = "Score"
  ) %>%
  mutate(
    Measure = case_when(
      Measure == "PAAS" & Technique == "movingGlobe" ~ "PAAS_MG",
      Measure == "PAAS" & Technique == "nonMovingGlobe" ~ "PAAS_NMG",
      Measure == "BORGRPE" & Technique == "movingGlobe" ~ "BORG_MG",
      Measure == "BORGRPE" & Technique == "nonMovingGlobe" ~ "BORG_NMG",
      TRUE ~ Measure
    ),
    ExertionType = case_when(
      str_detect(Measure, "PAAS") ~ "Cognitive load",
      str_detect(Measure, "BORG") ~ "Physical exertion",
      TRUE ~ "Unknown"
    )
  ) %>%
  select(UserID, Technique, Measure, Score, ExertionType) %>%
  mutate(
    Technique = as.factor(Technique),
    ExertionType = as.factor(ExertionType)
  )

data.scale.combined_exertion.art_anova <- art(Score ~ Technique * ExertionType + (1|UserID), data = data.scale.combined_exertion)

data.scale.combined_exertion.paas <- data.scale.combined_exertion %>%
  filter(ExertionType == "Cognitive load")

data.scale.combined_exertion.borg <- data.scale.combined_exertion %>%
  filter(ExertionType == "Physical exertion")

data.scale.combined_exertion.paas.art_anova <- art(
  Score ~ Technique + (1 | UserID),
  data = data.scale.combined_exertion.paas
)

data.scale.combined_exertion.borg.art_anova <- art(
  Score ~ Technique + (1|UserID), 
  data = data.scale.combined_exertion.borg
  )

anova(data.scale.combined_exertion.paas.art_anova)

anova(data.scale.combined_exertion.borg.art_anova)

data.scale.combined_exertion.paas %>%
  group_by(Technique) %>%
  summarise(mean_score = mean(Score, na.rm = TRUE)) %>%
  tidyr::pivot_wider(names_from = Technique, values_from = mean_score) %>%
  mutate(
    movingGlobe_mean = movingGlobe,
    nonMovingGlobe_mean = nonMovingGlobe,
    percent_diff = (movingGlobe - nonMovingGlobe) / nonMovingGlobe * 100
  ) %>%
  select(movingGlobe_mean, nonMovingGlobe_mean, percent_diff)

data.scale.combined_exertion.borg %>%
  group_by(Technique) %>%
  summarise(mean_score = mean(Score, na.rm = TRUE)) %>%
  tidyr::pivot_wider(names_from = Technique, values_from = mean_score) %>%
  mutate(
    movingGlobe_mean = movingGlobe,
    nonMovingGlobe_mean = nonMovingGlobe,
    percent_diff = (movingGlobe - nonMovingGlobe) / nonMovingGlobe * 100
  ) %>%
  select(movingGlobe_mean, nonMovingGlobe_mean, percent_diff)


ggplot(data.scale.combined_exertion, aes(x = Technique, y = Score, fill = ExertionType)) +
  geom_boxplot(width = 0.1, position = position_dodge(0.8)) +
  labs(
    x = "Scale Technique",
    y = "Score",
    title = "Distribution of Scores by technique and Exertion Type"
  ) +
  scale_fill_manual(
  values = c("Cognitive load" = "#a6bddb",  
            "Physical exertion" = "#d0d1e6")  
  ) +
  theme_minimal()

data.scale.combined_exertion %>%
  group_by(Technique, ExertionType) %>%
  summarise(
    mean_score = mean(Score),
    sd = sd(Score),
    n = n(),
    ci = qt(0.975, df = n - 1) * sd / sqrt(n),
    .groups = "drop"
  ) %>%
  mutate(Technique = case_when(
    Technique == "movingGlobe" ~ "Moving Globe",
    Technique == "nonMovingGlobe" ~ "Non Moving Globe",
    TRUE ~ as.character(Technique))) %>%
  ggplot(aes(x = Technique, y = mean_score, fill = ExertionType)) +
  geom_col(position = position_dodge(width = 0.7), width = 0.6) +
  geom_errorbar(aes(ymin = mean_score - ci, ymax = mean_score + ci),
                position = position_dodge(width = 0.7), width = 0.2) +
  labs(
    x = "Scale Technique",
    y = "Mean Score (95% CI)",
    fill = "Exertion Type",
    title = "Mean Score by Position Condition and Exertion Type"
  ) +
  scale_fill_manual(
  values = c("Cognitive load" = "#a6bddb",  
            "Physical exertion" = "#d0d1e6")  
  ) +
  theme_minimal()

data.scale.combined_exertion %>%
  filter(ExertionType == "Cognitive load") %>%
  group_by(Technique) %>%
  summarise(
    mean_score = mean(Score),
    sd = sd(Score),
    n = n(),
    ci = qt(0.975, df = n - 1) * sd / sqrt(n),
    .groups = "drop"
  ) %>%
  mutate(Technique = case_when(
    Technique == "movingGlobe" ~ "Maintain distance",
    Technique == "nonMovingGlobe" ~ "Maintain position",
    TRUE ~ as.character(Technique))) %>%
  ggplot(aes(x = Technique, y = mean_score, fill = Technique)) +
  geom_col(position = position_dodge(width = 0.7), width = 0.6) +
  geom_errorbar(aes(ymin = mean_score - ci, ymax = mean_score + ci),
                position = position_dodge(width = 0.7), width = 0.2) +
  labs(
    x = "Scaling technique",
    y = "Mean score (95% CI)",
    fill = "Scaling Technique",
    title = "Mean PAAS Score by Scaling Technique"
  ) +
  scale_fill_manual(
  values = c("Maintain distance" = "#a6bddb",  
            "Maintain position" = "#d0d1e6")  
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        plot.title = element_text(hjust = 0.5)) 

data.scale.combined_exertion %>%
  filter(ExertionType == "Physical exertion") %>%
  group_by(Technique) %>%
  summarise(
    mean_score = mean(Score),
    sd = sd(Score),
    n = n(),
    ci = qt(0.975, df = n - 1) * sd / sqrt(n),
    .groups = "drop"
  ) %>%
  mutate(Technique = case_when(
    Technique == "movingGlobe" ~ "Maintain distance",
    Technique == "nonMovingGlobe" ~ "Maintain position",
    TRUE ~ as.character(Technique))) %>%
  ggplot(aes(x = Technique, y = mean_score, fill = Technique)) +
  geom_col(position = position_dodge(width = 0.7), width = 0.6) +
  geom_errorbar(aes(ymin = mean_score - ci, ymax = mean_score + ci),
                position = position_dodge(width = 0.7), width = 0.2) +
  labs(
    x = "Scaling technique",
    y = "Mean score (95% CI)",
    fill = "Scaling Technique",
    title = "Mean BORG RPE Score by Scaling Technique"
  ) +
  scale_fill_manual(
  values = c("Maintain distance" = "#a6bddb",  
            "Maintain position" = "#d0d1e6")  
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        plot.title = element_text(hjust = 0.5)) 

data.scale.combined_exertion %>%
  group_by(Technique, ExertionType) %>%
  summarise(mean_score = mean(Score))

```

###### Preference

```{r Scale - Preference}

data.scale.qualitative %>%
  count(Scale_preference) %>%
  mutate(
    percent = n / sum(n),
    ncount = paste0(n, "\n", percent_format()(percent))
  ) %>%
  mutate(
    Preference = case_when(
    Scale_preference == "maintainDistance" ~ "Maintain Globe's Distance",
    Scale_preference == "maintainGlobe" ~ "Maintain Globe's Position",
    Scale_preference == "noPreference" ~ "No Preference"
    )) %>%
  ggplot(aes(x = "", y = n, fill = Preference)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = ncount), position = position_stack(vjust = 0.5), size = 4) +
  labs(
    title = "Distribution of Scale technique Preferences",
    fill = "Preference"
  ) +
  scale_fill_manual(
  values = c("Maintain Globe's Distance" = "#a6bddb",  
            "Maintain Globe's Position" = "#d0d1e6",
            "No Preference" = "#b8e0d2")  
  ) +
  theme_void()

data.scale.qualitative %>%
  count(Scale_preference) %>%
  mutate(
    Preference = case_when(
      Scale_preference == "maintainDistance" ~ "Maintain distance",
      Scale_preference == "maintainGlobe" ~ "Maintain position",
      Scale_preference == "noPreference" ~ "No preference"
    )
  ) %>%
  ggplot(aes(x = n, y = Preference, fill = Preference)) +
  geom_col(width = 0.5) +
  geom_text(aes(label = n), hjust = -0.9, size = 5, family = "Times New Roman") +
  labs(
    x = NULL,
    y = NULL,
    fill = "Preference"
  ) +
  scale_fill_manual(
    values = c(
      "Maintain distance" = "gray60",
      "Maintain position" = "gray80",
      "No preference" = "gray90"
    )
  ) +
  scale_y_discrete(limits = c("No preference", "Maintain position", "Maintain distance")) +  # fixes order
  theme_minimal(base_family = "Times New Roman") +
  theme(
    plot.title = element_blank(),
    legend.position = "none",
    plot.margin = margin(10, 40, 10, 10),
    axis.text.y = element_text(size = 18),
    axis.text.x = element_blank()
  ) +
  xlim(0, NA)


ggsave("Scaling_preference_bar.svg")
```

###### Comments

```{r Scale - Comments}
data.scale.qualitative %>%
  mutate(
    Scale_preference = case_when(
      Scale_preference == "maintainDistance" ~ "Maintains distance",
      Scale_preference == "maintainGlobe" ~ "Maintains position",
      Scale_preference == "noPreference" ~ "No Preference",
      TRUE ~ Scale_preference
    )
  ) %>%
  rename(
    "Participant ID" = UserID,
    "Scale Preference" = Scale_preference,
    "Scale Feedback" = Scale_feedback
  ) %>%
  kable(caption = "User Feedback Summary - Scale", align = "c") %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = FALSE,
    position = "center"
  ) %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#f7f7f7") %>%
  scroll_box(width = "100%", height = "400px")

```


###### Summary


### Study: Combined Gesture Preference and Feedback

```{r Combined Gesture Preference and Feedback}

# Facet titles
interaction_labels <- c(
  Positioning_preference = "Positioning Preference",
  Rotation_preference = "Rotation Preference",
  Scale_preference = "Scale Preference"
)

# Custom color palette
custom_colors <- c(
  "#a6bddb", "#d0d1e6", "#b8e0d2", "#f6c5af", "#fef9b0",
  "#f3c1d3", "#a3c6c4", "#fcd5ce", "#cfd8dc"
)

data.combined.qualitative %>%
  mutate(
    Positioning_preference = case_when(
      Positioning_preference == "adaptiveOrientation" ~ "Adaptive Orientation",
      Positioning_preference == "staticOrientation" ~ "Static Orientation",
      Positioning_preference == "noPreference" ~ "No Preference"
    ),
    Rotation_preference = case_when(
      Rotation_preference == "oneHandedPreference" ~ "One-Handed",
      Rotation_preference == "twoHandedPreference" ~ "Two-Handed",
      Rotation_preference == "noPreference" ~ "No Preference"
    ),
    Scale_preference = case_when(
      Scale_preference == "maintainDistance" ~ "Maintain Distance",
      Scale_preference == "maintainGlobe" ~ "Maintain Position",
      Scale_preference == "noPreference" ~ "No Preference"
    )
  ) %>%
  pivot_longer(
    cols = c(Positioning_preference, Scale_preference, Rotation_preference),
    names_to = "Interaction_Type",
    values_to = "Preference"
  ) %>%
  mutate(
    Interaction_Type = factor(Interaction_Type, levels = c(
      "Positioning_preference", "Scale_preference", "Rotation_preference"
    )),
    Preference = case_when(
      Interaction_Type == "Positioning_preference" ~ factor(Preference,
        levels = c("Static Orientation", "Adaptive Orientation", "No Preference")),
      Interaction_Type == "Scale_preference" ~ factor(Preference,
        levels = c("Maintain Distance", "Maintain Position", "No Preference")),
      Interaction_Type == "Rotation_preference" ~ factor(Preference,
        levels = c("One-Handed", "Two-Handed", "No Preference")),
      TRUE ~ Preference
    )
  ) %>%
  ggplot(aes(x = Preference, fill = Preference)) +
  geom_bar(show.legend = FALSE, width = 0.6) +
  geom_text(stat = "count", aes(label = ..count..), hjust = -0.3, size = 5, family = "Times New Roman") +
  facet_wrap(
    ~ Interaction_Type,
    scales = "free",
    labeller = labeller(Interaction_Type = c(
      Positioning_preference = "Positioning",
      Scale_preference = "Scaling",
      Rotation_preference = "Rotating"
    )),
    ncol = 1
  ) +
  scale_y_continuous(breaks = 1:10, limits = c(0, 10)) +
  scale_fill_manual(values = c(
    "Static Orientation" = "gray60",
    "Adaptive Orientation" = "gray70",
    "No Preference" = "gray90",
    "Maintain Distance" = "gray60",
    "Maintain Position" = "gray70",
    "One-Handed" = "gray60",
    "Two-Handed" = "gray70"
  )) +
  coord_flip() +
  labs(
    x = NULL,
    y = "Count"
  ) +
  theme_minimal(base_family = "Times New Roman", base_size = 14) +
  theme(
    axis.text.x = element_blank(),   
    axis.text.y = element_text(size = 13),
    strip.text = element_text(face = "bold", size = 14),
    plot.title = element_blank()
  )

ggsave("combined_preference.svg")

data.combined.qualitative %>%
  mutate(
    Positioning_preference = case_when(
      Positioning_preference == "adaptiveOrientation" ~ "Adaptive Orientation",
      Positioning_preference == "staticOrientation" ~ "Static Orientation",
      Positioning_preference == "noPreference" ~ "No Preference",
      TRUE ~ Positioning_preference
    ),
    Rotation_preference = case_when(
      Rotation_preference == "oneHandedPreference" ~ "One Handed Preference",
      Rotation_preference == "twoHandedPreference" ~ "Two Handed Preference",
      Rotation_preference == "noPreference" ~ "No Preference",
      TRUE ~ Scale_preference
    ),
    Scale_preference = case_when(
      Scale_preference == "maintainDistance" ~ "Maintains distance",
      Scale_preference == "maintainGlobe" ~ "Maintains position",
      Scale_preference == "noPreference" ~ "No Preference",
      TRUE ~ Scale_preference
    ),
  ) %>%
  rename(
    "Participant ID" = UserID,
    "Positioning Preference" = Positioning_preference,
    "Rotating Preference" = Rotation_preference,
    "Scale Preference" = Scale_preference,
    "Combined Feedback" = Combined_feedback
  ) %>%
  kable(caption = "User Feedback Summary - Scale", align = "c") %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = FALSE,
    position = "center"
  ) %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#f7f7f7") %>%
  scroll_box(width = "100%", height = "400px")

# data.positioning.qualitative %>%
#   full_join(data.rotating.qualitative, by = "UserID") %>%
#   full_join(data.scale.qualitative, by = "UserID") %>%
#   full_join(data.combined.qualitative, by = "UserID") %>%
#   kable(caption = "User Feedback Summary - Scale", align = "c") %>%
#   kable_styling(
#     bootstrap_options = c("striped", "hover", "condensed", "responsive"),
#     full_width = FALSE,
#     position = "center"
#   ) %>%
#   column_spec(1, bold = TRUE) %>%
#   row_spec(0, bold = TRUE, background = "#f7f7f7") %>%
#   scroll_box(width = "100%", height = "400px")

```

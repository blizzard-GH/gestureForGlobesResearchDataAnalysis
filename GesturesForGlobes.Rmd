---
title: "Gestures for Positioning, Scaling, and Rotating Virtual Globes"
author: "Faisal Agung Abdillah"
date: "2025-05-08"
output:
  html_document:
    code_folding: show
    toc: true
    toc_float: true
    toc_depth: 6
    theme: flatly
    highlight: haddock
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Gestures for Globes Research

## Data and Libraries Load

```{r}
library(tidyverse)
library(dplyr)
library(car)
library(ggplot2)
library(lubridate)
library(scales)
library(ARTool)
library(knitr)

data <- read_csv("study_tasks.csv")
demographic <- read_csv("final_introductory.csv")
positioning_NRG <- read_csv("final_positioning_NRG.csv")
positioning_RG <- read_csv("final_positioning_RG.csv")
positioning_preference <- read_csv("final_positioning_comparison.csv")
rotation_OH <- read_csv("final_rotation_OH.csv")
rotation_TH <- read_csv("final_rotation_TH.csv")
rotation_preference <- read_csv("final_rotation_comparison.csv")
scale_MG <- read_csv("final_scale_MG.csv")
scale_NMG <- read_csv("final_scale_NMG.csv")
scale_preference <- read_csv("final_scale_comparison.csv")
combined_preference <- read_csv("final_outro_comparison.csv")

summary(data)

summary(demographic)

summary(positioning_NRG)

summary(positioning_RG)

summary(positioning_preference)

summary(rotation_OH)

summary(rotation_TH)

summary(rotation_preference)

summary(scale_MG)

summary(scale_NMG)

summary(scale_preference)

summary(combined_preference)
```

## Participants Demographic Information

```{r Demographic}
# Total number of participants
length(unique(data$UserID))

# Participants' gender distribution
demographic.gender <-  demographic %>%
  select(UserID, Gender) %>%
  distinct() %>%
  group_by(Gender) %>%
  summarise(count = n()) %>%
  mutate(percentage = round(count / sum(count) * 100, 1), percentage = paste0(percentage, "%"))

demographic.gender

# Participants' gender distribution chart
ggplot(demographic.gender, aes(x = "", y = count, fill = Gender)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = percentage), position = position_stack(vjust = 0.5), size = 4) +
  labs(title = "Distribution of Participants' Gender") +
  theme_void()

# Participants' academic level distribution
demographic.academic_level <-  demographic %>%
  select(UserID, Academic_level) %>%
  distinct() %>%
  group_by(Academic_level) %>%
  summarise(count = n()) %>%
  mutate(percentage = round(count / sum(count) * 100, 1), graph_label = paste0(percentage, "%")) %>%
  rename(`Academic levels` = Academic_level)

demographic.academic_level

# Participants' academic level distribution chart
ggplot(demographic.academic_level, aes(x = "", y = count, fill = `Academic levels`)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = graph_label), position = position_stack(vjust = 0.5), size = 4) +
  labs(title = "Distribution of Participants' Academic Level") +
  theme_void() 

# Participants' previous AR/VR experience distribution
demographic.ARVR_exp <-  demographic %>%
  select(UserID, Exp_ARVR ) %>%
  distinct() %>%
  group_by(Exp_ARVR) %>%
  summarise(count = n()) %>%
  mutate(percentage = round(count / sum(count) * 100, 1), 
         label = paste0(percentage, "%"),
         ShortLabel = fct_recode(Exp_ARVR,
                          "No experience" = "I have no experience")
) %>%
  rename(`Previous AR/VR experience` = ShortLabel)

demographic.ARVR_exp

# Participants' previous AR/VR experience distribution chart
ggplot(demographic.ARVR_exp, aes(x = "", y = count, fill = `Previous AR/VR experience`)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = label), position = position_stack(vjust = 0.5), size = 4) +
  labs(title = "Distribution of Participants Previous AR/VR Experience") +
  theme_void() 

# Participants' previous globe experience distribution
demographic.globes_exp <- demographic %>%
  select(UserID, Globe_usage_frequency) %>%
  distinct() %>%
  group_by(Globe_usage_frequency) %>%
  summarise(count = n()) %>%
  mutate(percentage = round(count / sum(count) * 100, 1),
         graph_label = paste0(percentage, "%")) %>%
  rename(`Previous globes experience` = Globe_usage_frequency)

demographic.globes_exp

# Participants' previous globe experience distribution chart
ggplot(demographic.globes_exp, aes(x = "", y = count, fill = `Previous globes experience`)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = graph_label), position = position_stack(vjust = 0.5), size = 4) +
  labs(title = "Distribution of Participants Previous AR/VR Experience") +
  theme_void() 

# Participants' previous Apple Vision Pro Experience distribution
demographic.visionpro_exp <- demographic %>%
  select(UserID, Have_used_VisionPro) %>%
  distinct() %>%
  group_by(Have_used_VisionPro) %>%
  summarise(count = n()) %>%
  mutate(
    percentage = round(count / sum(count) * 100, 1),
    graph_label = paste0(percentage, "%")
  ) %>%
  rename(`Have used Apple Vision Pro` = Have_used_VisionPro)
  
demographic.visionpro_exp
  
# Participants' previous Apple Vision Pro Experience distribution chart
ggplot(demographic.visionpro_exp, aes(x = "", y = count, fill = `Have used Apple Vision Pro`)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = graph_label), position = position_stack(vjust = 0.5), size = 4) +
  labs(title = "Distribution of Participants Previous AR/VR Experience") +
  theme_void()   

```

## User Study

### Study: Positioning

#### Positioning Data Preparation

```{r Positioning Data Preparation}
data.positioning <- data %>%
  mutate(positionCondition = if_else(rotateGlobeWhileDragging, "rotatingGlobe", "nonRotatingGlobe")) %>%
  select(-rotateGlobeWhileDragging) %>%
  inner_join(demographic, by = "UserID") %>%
  inner_join(positioning_NRG, by = "UserID") %>%
  rename(
    PAAS_NRG = Mentally_demanding,
    BORG_NRG = Physically_demanding
  ) %>%
  mutate(
    PAAS_NRG = as.numeric(str_extract(PAAS_NRG, "\\d+(\\.\\d+)?")),
    BORG_NRG = as.numeric(str_extract(BORG_NRG, "\\d+(\\.\\d+)?"))
  ) %>%
  mutate(
    PAAS_NRG = if_else(positionCondition == "nonRotatingGlobe", PAAS_NRG, NA_real_),
    BORG_NRG = if_else(positionCondition == "nonRotatingGlobe", BORG_NRG, NA_real_)
  ) %>%
  inner_join(positioning_RG, by = "UserID") %>%
  rename(
    PAAS_RG = Mentally_demanding,
    BORG_RG = Physically_demanding
  ) %>%
  mutate(
    PAAS_RG = as.numeric(str_extract(PAAS_RG, "\\d+(\\.\\d+)?")),
    BORG_RG = as.numeric(str_extract(BORG_RG, "\\d+(\\.\\d+)?"))
  ) %>%
  mutate(
    PAAS_RG = if_else(positionCondition == "rotatingGlobe", PAAS_RG, NA_real_),
    BORG_RG = if_else(positionCondition == "rotatingGlobe", BORG_RG, NA_real_)
  ) %>%
  inner_join(positioning_preference, by = "UserID") %>%
  rename(
    behaviour_preference = Positioning_preference,
    behaviour_feedback = Positioning_feedback
  ) %>%
  mutate(
      behaviour_preference = case_when(
    str_detect(behaviour_preference, "Static orientation") ~ "staticOrientation",
    str_detect(behaviour_preference, "Adaptive orientation") ~ "adaptiveOrientation",
    str_detect(behaviour_preference, "no preference") ~ "noPreference",
    TRUE ~ "unknown"
  ) ) %>%
  filter(Type == "positionTask") %>%
  select(UserID, TaskID, ActionID, positionCondition, distance, direction, Date, ActionStatus, main_translation_x,
  main_translation_y, main_translation_z, target_translation_x, target_translation_y, target_translation_z, 
  match_accuracy_result, status, PAAS_NRG, BORG_NRG, PAAS_RG, BORG_RG, behaviour_preference, behaviour_feedback) %>%
  mutate(distance = as.factor(distance), 
         direction = as.factor(direction), 
         positionCondition = as.factor(positionCondition),
         status = as.factor(status),
         behaviour_preference = as.factor(behaviour_preference))

```

#### Position Task Study

##### Accuracy

###### Normality

```{r PositionStudy - Accuracy - Normality}

data.positioning.matched <- data.positioning %>%
  filter(status == "Matched")

shapiro.test(data.positioning.matched$match_accuracy_result)

hist(data.positioning.matched$match_accuracy_result, breaks = 100,
     main = "Histogram (Zoomed)", xlab = "Accuracy",
     col = "lightblue", xlim = c(0, 0.06))

plot(density(data.positioning.matched$match_accuracy_result), 
     main = "Density Plot (Zoomed)", xlab = "Accuracy",
     col = "blue", lwd = 2, xlim = c(0, 0.6))
```

Although the w value is close to 1, the p value is below 0.05 so we reject null hypothesis that the data is normally distributed
So, we cannot use one way ANOVA, instead, we use Wilcoxon signed-rank test

###### Statistical Tests

```{r PositionStudy - Accuracy - Statistical tests}

data.positioning.matched.accuracy_avg.long <- data.positioning.matched %>%
  group_by(UserID, positionCondition, distance, direction) %>%
  summarise(mean_accuracy = mean(match_accuracy_result, na.rm = TRUE), .groups = 'drop')

data.positioning.matched.art <- art(mean_accuracy ~ positionCondition * distance * direction + (1|UserID), data = data.positioning.matched.accuracy_avg.long)

anova(data.positioning.matched.art)

	# •	The main effect of positionCondition was not statistically significant: F(1, 99) = 0.89, p = 0.348.
	# •	The main effect of distance was statistically significant: F(1, 99.55) = 8.58, p = 0.0042 (**).
	# •	The main effect of direction was also statistically significant: F(2, 99.53) = 3.51, p = 0.0335 (*).
	# •	The interaction between positionCondition and distance was not significant: F(1, 99) = 0.88, p = 0.349.
	# •	The interaction between positionCondition and direction was not significant: F(2, 99) = 0.22, p = 0.803.
	# •	The interaction between distance and direction was not significant: F(2, 99.51) = 0.25, p = 0.778.
	# •	The three-way interaction (positionCondition × distance × direction) was not significant: F(2, 99) = 1.62, p = 0.202.

# There were significant main effects of both distance and direction on mean accuracy, indicating that participants’ accuracy was influenced independently by how far the task was and from which direction it came. However, positionCondition had no significant effect, and no interaction terms reached statistical significance. This suggests that the combined effects of position, distance, and direction do not differentially impact accuracy beyond the main effects of distance and direction alone.

ggplot(data.positioning.matched.accuracy_avg.long, aes(x = positionCondition, y = mean_accuracy, group = UserID)) +
  geom_line(aes(color = as.factor(UserID)),  linewidth = 1, alpha = 0.6) +
  geom_point(size = 3) +
  facet_wrap(~ distance + direction) + 
  labs(title = "Paired Accuracy by Globe Behaviour, Globes' Distance and Direction",
       x = "Behaviour",
       y = "Match Accuracy") +
  theme_minimal() +
  theme(strip.text = element_text(size = 12, face = "bold"))

ggplot(data.positioning.matched.accuracy_avg.long, aes(x = positionCondition, y = mean_accuracy)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  facet_wrap(~ distance + direction) + 
  labs(title = "Boxplots of Accuracy by Globe Behaviour, Globes' Distance and Direction",
       x = "Behaviour",
       y = "Match Accuracy") +
  theme_minimal()
```

##### Completion Time

###### Normality

```{r PositionStudy - Completion Time - Normality}

data.positioning.taskCompletion_avg <- data.positioning %>%
  group_by(UserID, TaskID) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  )

shapiro.test(data.positioning.taskCompletion_avg$completion_time)

```

###### Statistical Tests

```{r PositionStudy - Completion Time - Statistical Tests}

data.positioning.taskCompletion_avg.long <- data.positioning %>%
  group_by(UserID, positionCondition, TaskID, distance, direction) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  group_by(UserID, positionCondition, distance, direction) %>%
  summarise(
    avg_completion_time = mean(completion_time),
    .groups = "drop"
  )

data.positioning.taskCompletion_avg.art <- art(avg_completion_time ~ positionCondition * distance * direction + (1|UserID), data = data.positioning.taskCompletion_avg.long)

anova(data.positioning.taskCompletion_avg.art)

# •	positionCondition had no significant effect on average task completion time:F(1, 99.00) = 0.61, p = 0.435
# •	distance also showed no significant effect:F(1, 100.62) = 1.75, p = 0.189
# •	direction showed a statistically significant main effect:F(2, 100.86) = 6.39, p = 0.0024 (**), suggesting direction influences how long tasks take
# •	The interaction between positionCondition and distance was not significant:F(1, 99.00) = 0.24, p = 0.624
# •	The interaction between positionCondition and direction was not significant:F(2, 99.00) = 0.50, p = 0.605
# •	The interaction between distance and direction was not significant:F(2, 100.71) = 0.57, p = 0.565
# •	The three-way interaction (positionCondition × distance × direction) was also not significant:F(2, 99.00) = 0.44, p = 0.647
# 
# Only direction had a statistically significant effect on average task completion time, indicating that the direction from which the task was approached meaningfully influenced how long participants took to complete it. Other factors—positionCondition, distance, and all interaction terms—did not have significant effects. This suggests that regardless of position or distance, direction alone may account for differences in task completion time in this context.

ggplot(data.positioning.taskCompletion_avg.long, aes(x = positionCondition, y = avg_completion_time, group = UserID)) +
  geom_line(aes(color = as.factor(UserID)), linewidth = 1, alpha = 0.6) +
  geom_point(size = 3) +
  facet_wrap(~ distance + direction) + 
  labs(
    title = "Paired Task Completion Time by Behaviour, Distance, and Direction",
    x = "Behaviour",
    y = "Completion Time (minutes)",
    color = "UserID"
  ) +
  theme_minimal()

ggplot(data.positioning.taskCompletion_avg.long, aes(x = positionCondition, y = avg_completion_time)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  facet_wrap(~ distance + direction) + 
  labs(title = "Boxplots of Task Completion Time by Behaviour, Distance, and Directio",
       x = "Behaviour",
       y = "Task Completion Time") +
  theme_minimal()

```


##### Subjective Measures

###### Physical and Mental Exertion

```{r Subjective Measures - Physical and Mental Exertion}

data.positioning.long <- data.positioning %>% 
  select(UserID, positionCondition, PAAS_RG, BORG_RG, PAAS_NRG, BORG_NRG) %>%
  distinct() %>%
  pivot_longer(
    cols = c(PAAS_RG, BORG_RG, PAAS_NRG, BORG_NRG),
    names_to = "Measure",
    values_to = "Score"
  ) %>%
  filter(!is.na(Score)) %>%  
  mutate(
    ExertionType = case_when(
      str_detect(Measure, "PAAS") ~ "Cognitive load",
      str_detect(Measure, "BORG") ~ "Physical exertion",
      TRUE ~ "Unknown"
    ),
    UserID = as.factor(UserID),
    ExertionType = as.factor(ExertionType)
  ) %>%
  group_by(UserID, positionCondition, Measure)

data.positioning.long.art_anova <- art(Score ~ positionCondition * ExertionType + (1|UserID), data = data.positioning.long)
anova(data.positioning.long.art_anova)

# 	•	Main effect of positionCondition: F(1, 33) = 12.55, p = 0.0012 This is statistically significant, indicating that task positioning condition (e.g., rotating vs non-rotating globe) has a significant effect on the overall exertion score (which includes cognitive load and physical exertion).
#   •	Main effect of ExertionType: F(1, 33) = 12.81, p = 0.0011 Also statistically significant, meaning that there is a clear difference between cognitive load (PAAS) and physical exertion (BORG) scores regardless of the positioning condition.
# 	•	Interaction effect (positionCondition × ExertionType): F(1, 33) = 0.18, p = 0.6774, suggesting that the effect of positioning condition does not depend on the type of exertion, and vice versa. The differences in PAAS and BORG scores are consistent across both positioning conditions.
# Both the positioning condition and type of exertion significantly influence the exertion score independently, but there is no interaction effect. This means that while both factors matter, their effects do not amplify or diminish each other. For example, rotating vs non-rotating globes affects scores, and cognitive vs physical exertion shows distinct levels, but the difference between PAAS and BORG scores remains similar across positioning conditions.

ggplot(data.positioning.long, aes(x = positionCondition, y = Score, fill = ExertionType)) +
  geom_boxplot(width = 0.1, position = position_dodge(0.8)) +
  labs(
    x = "Position Condition",
    y = "Score",
    title = "Distribution of Scores by Behaviour and Exertion Type"
  ) +
  theme_minimal()
```

###### Preference

```{r Positioning - Preference}

data.positioning %>%
  select(UserID, behaviour_preference) %>%
  distinct() %>%  
  count(behaviour_preference) %>%
  mutate(
    percent = n / sum(n),
    ncount = paste0(n, "\n", percent_format()(percent))
  ) %>%
  ggplot(aes(x = "", y = n, fill = behaviour_preference)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = ncount), position = position_stack(vjust = 0.5), size = 4) +
  labs(
    title = "Distribution of Positioning Behaviour Preferences",
    fill = "Preference"
  ) +
  theme_void()

```

###### Comments

```{r Positioning - comments}

data.positioning.preference.summary <- data.positioning %>%
  mutate(
    behaviour_preference = case_when(
      behaviour_preference == "staticOrientation" ~ "Static Orientation",
      behaviour_preference == "adaptiveOrientation" ~ "Adaptive Orientation",
      behaviour_preference == "noPreference" ~ "No Preference",
      TRUE ~ behaviour_preference
    )
  ) %>%
  group_by(UserID) %>%
  summarise(
    behaviour_preference = first(behaviour_preference),
    behaviour_feedback = first(behaviour_feedback),
    .groups = "drop"
  )

kable(data.positioning.preference.summary, caption = "User Feedback Summary - Positioning")

```

###### Summary

### Study: Rotating

#### Rotating Data Preparation

```{r Rotating Data Preparation}
data.rotating <- data %>%
  mutate(rotationCondition = if_else(oneHandedRotationGesture, "oneHanded", "twoHanded")) %>%
  select(-oneHandedRotationGesture) %>%
  inner_join(demographic, by = "UserID") %>%
  inner_join(rotation_OH, by = "UserID") %>%
  rename(
    PAAS_OH = Mentally_demanding,
    BORG_OH = Physically_demanding
  ) %>%
  mutate(
    PAAS_OH = as.numeric(str_extract(PAAS_OH, "\\d+(\\.\\d+)?")),
    BORG_OH = as.numeric(str_extract(BORG_OH, "\\d+(\\.\\d+)?"))
  ) %>%
  mutate(
    PAAS_OH = if_else(rotationCondition == "oneHanded", PAAS_OH, NA_real_),
    BORG_OH = if_else(rotationCondition == "oneHanded", BORG_OH, NA_real_)
  ) %>%
  inner_join(rotation_TH, by = "UserID") %>%
  rename(
    PAAS_TH = Mentally_demanding,
    BORG_TH = Physically_demanding
  ) %>%
  mutate(
    PAAS_TH = as.numeric(str_extract(PAAS_TH, "\\d+(\\.\\d+)?")),
    BORG_TH = as.numeric(str_extract(BORG_TH, "\\d+(\\.\\d+)?"))
  ) %>%
  mutate(
    PAAS_TH = if_else(rotationCondition == "twoHanded", PAAS_TH, NA_real_),
    BORG_TH = if_else(rotationCondition == "twoHanded", BORG_TH, NA_real_)
  ) %>%
  inner_join(rotation_preference, by = "UserID") %>%
  rename(
    behaviour_preference = Rotation_preference,
    behaviour_feedback = Rotation_feedback
  ) %>%
  mutate(
      behaviour_preference = case_when(
    str_detect(behaviour_preference, "One-handed") ~ "oneHandedPreference",
    str_detect(behaviour_preference, "Two-handed") ~ "twoHandedPreference",
    str_detect(behaviour_preference, "no preference") ~ "noPreference",
    TRUE ~ "unknown"
  )) %>%
  filter(Type == "rotationTask") %>%
  select(UserID, TaskID, ActionID, rotationCondition, complexity, Date, ActionStatus, main_rotation_x,
  main_rotation_y, main_rotation_z, main_rotation_w, target_rotation_x, target_rotation_y, target_rotation_z,
  target_rotation_w,match_accuracy_result, status, PAAS_OH, BORG_OH, PAAS_TH, BORG_TH, behaviour_preference, behaviour_feedback) %>%
  mutate(complexity = as.factor(complexity), 
         rotationCondition = as.factor(rotationCondition),
         status = as.factor(status),
         behaviour_preference = as.factor(behaviour_preference))

```

#### Rotation Task Study

##### Accuracy

###### Normality

```{r Rotation Task Study - Accuracy - Normality}

data.rotating.matched <- data.rotating %>%
  filter(status == "Matched")

shapiro.test(data.rotating.matched$match_accuracy_result)

hist(data.rotating.matched$match_accuracy_result, breaks = 100,
     main = "Histogram (Zoomed)", xlab = "Accuracy",
     col = "lightblue", xlim = c(0, 0.5))

plot(density(data.rotating.matched$match_accuracy_result), 
     main = "Density Plot (Zoomed)", xlab = "Accuracy",
     col = "blue", lwd = 2, xlim = c(0, 0.5))

```

Although the w value is close to 1, the p value is below 0.05 so we reject null hypothesis that the data is normally distributed
So, we cannot use one way ANOVA, instead, we use Wilcoxon signed-rank test

###### Statistical tests

```{r Rotation Task Study - Accuracy - Statistical Tests}
 
data.rotating.matched.accuracy_avg.long <- data.rotating.matched %>%
  group_by(UserID, rotationCondition, complexity) %>%
  summarise(mean_accuracy = mean(match_accuracy_result, na.rm = TRUE), .groups = 'drop') 

data.rotating.matched.art <- art(mean_accuracy ~ rotationCondition * complexity + (1|UserID), data = data.rotating.matched.accuracy_avg.long)

anova(data.rotating.matched.art)

	# •	rotationCondition: F(1, 33) = 4.67, p = 0.038 Significant: rotation affects accuracy
	# •	complexity: F(1, 33) = 20.74, p < 0.001 Highly significant: complexity affects accuracy
	# •	rotationCondition × complexity: F(1, 33) = 0.25, p = 0.62 Not significant: no interaction effect

# The ART ANOVA revealed significant main effects of both rotation condition and complexity on accuracy. Rotation condition had a modest but significant effect (p = 0.038), while complexity showed a strong influence (p < 0.001). However, there was no significant interaction between rotation and complexity (p = 0.62), indicating that the effects of each factor on accuracy are independent and do not influence each other.


ggplot(data.rotating.matched.accuracy_avg.long, aes(x = rotationCondition, y = mean_accuracy, group = UserID)) +
  geom_line(aes(color = as.factor(UserID)), linewidth = 1, alpha = 0.6) +
  geom_point(size = 3) +
  facet_wrap(~ complexity) + 
  labs(
    title = "Paired Task Match Accuracy by Technique and Complexity",
    x = "Technique",
    y = "Accuracy",
    color = "UserID"
  ) +
  theme_minimal() +
  theme(strip.text = element_text(size = 12, face = "bold"))

ggplot(data.rotating.matched.accuracy_avg.long, aes(x = rotationCondition, y = mean_accuracy)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  facet_wrap(~ complexity) + 
  labs(title = "Boxplots of Task Accuracy by Technique and Complexity",
       x = "Technique",
       y = "Match Accuracy") +
  theme_minimal()
```

##### Completion Time

###### Normality

```{r Rotation Task Study - Completion Time - Normality}

data.rotating.taskCompletion_avg <- data.rotating %>%
  group_by(UserID, TaskID) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  )

shapiro.test(data.rotating.taskCompletion_avg$completion_time)
```

###### Statistical Tests

```{r Rotation Task Study - Completion Time - Statistical Tests}
data.rotating.taskCompletion_avg.long <- data.rotating %>%
  group_by(UserID, rotationCondition, complexity, TaskID) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  group_by(UserID, rotationCondition, complexity) %>%
  summarise(
    avg_completion_time = mean(completion_time),
    .groups = "drop"
  )

data.rotating.taskCompletion_avg.art <- art(avg_completion_time ~ rotationCondition * complexity + (1|UserID), data = data.rotating.taskCompletion_avg.long)

anova(data.rotating.taskCompletion_avg.art)

	# •	rotationCondition: F(1, 33) = 8.44, p = 0.0065 (**) Statistically significant — rotation has a clear effect on completion time
	# •	complexity: F(1, 33) = 37.75, p < 0.0001 (***) Statistically significant — complexity strongly affects completion time
	# •	rotationCondition × complexity: F(1, 33) = 2.36, p = 0.1344 Not significant — no evidence of interaction between rotation and complexity

ggplot(data.rotating.taskCompletion_avg.long, 
       aes(x = rotationCondition, y = avg_completion_time, group = UserID)) +
  geom_line(aes(color = as.factor(UserID)), linewidth = 1, alpha = 0.6) +
  geom_point(size = 3) +
  facet_wrap(~ complexity) +
  labs(
    title = "Paired Task Completion Time by Technique and Complexity",
    x = "Technique",
    y = "Average Completion Time (minutes)",
    color = "UserID"
  ) +
  theme_minimal() +
  theme(strip.text = element_text(size = 12, face = "bold"))

ggplot(data.rotating.taskCompletion_avg.long, aes(x = rotationCondition, y = avg_completion_time)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  facet_wrap(~ complexity) +
  labs(title = "Boxplots of Task Completion Time by Technique and Complexity",
       x = "Technique",
       y = "Task Completion Time") +
  theme_minimal()

```


##### Subjective Measures

###### Physical and Mental Exertion

```{r Positioning - Physical and Mental Exertion}
data.rotating.long <- data.rotating %>% 
  select(UserID, rotationCondition, PAAS_OH, BORG_OH, PAAS_TH, BORG_TH) %>%
  distinct() %>%
  pivot_longer(
    cols = c(PAAS_OH, BORG_OH, PAAS_TH, BORG_TH),
    names_to = "Measure",
    values_to = "Score"
  ) %>%
  filter(!is.na(Score)) %>%  
  mutate(
    ExertionType = case_when(
      str_detect(Measure, "PAAS") ~ "Cognitive load",
      str_detect(Measure, "BORG") ~ "Physical exertion",
      TRUE ~ "Unknown"
    ),
    UserID = as.factor(UserID),
    ExertionType = as.factor(ExertionType)
  ) %>%
  group_by(UserID, rotationCondition, Measure)
  
data.rotating.long.art_anova <- art(Score ~ rotationCondition * ExertionType + (1|UserID), data = data.rotating.long)
anova(data.rotating.long.art_anova)

# 	•	Main effect of rotationCondition: F(1, 33) = 4.28, p = 0.0466 This is statistically significant at the 0.05 level, indicating that rotating vs non-rotating globe conditions have a meaningful impact on participants’ perceived exertion scores (cognitive or physical).
#	  •	Main effect of ExertionType: F(1, 33) = 20.75, p < 0.001 This is highly significant,  showing a strong difference between cognitive load (PAAS) and physical exertion (BORG) scores, regardless of the globe rotation condition.
#  	•	Interaction effect (rotationCondition × ExertionType): F(1, 33) = 0.016, p = 0.8990 Not significant. Suggesting that the difference between cognitive and physical exertion is consistent across both rotation conditions. The type of exertion does not change depending on whether the globe was rotating or not.
# Both rotation condition and exertion type have independent effects on perceived exertion. Participants reported different exertion levels between rotating and non-rotating globes, and also between cognitive and physical demands. However, there is no interaction, meaning the relative difference between PAAS and BORG remains stable across rotation types.

ggplot(data.rotating.long, aes(x = rotationCondition, y = Score, fill = ExertionType)) +
  geom_boxplot(width = 0.1, position = position_dodge(0.8)) +
  labs(
    x = "Rotation Condition",
    y = "Score",
    title = "Distribution of Scores by Technique and Exertion Type"
  ) +
  theme_minimal()
```

###### Preference

```{r Rotating - Preference}
data.rotating %>%
  select(UserID, behaviour_preference) %>%
  distinct() %>%  
  count(behaviour_preference) %>%
  mutate(
    percent = n / sum(n),
    ncount = paste0(n, "\n", percent_format()(percent))
  ) %>%
  ggplot(aes(x = "", y = n, fill = behaviour_preference)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = ncount), position = position_stack(vjust = 0.5), size = 4) +
  labs(
    title = "Distribution of Rotation Behaviour Preferences",
    fill = "Preference"
  ) +
  theme_void()
```


###### Comments


```{r Rotating - Comments}
data.rotating.preference.summary <- data.rotating %>%
  mutate(
    behaviour_preference = case_when(
      behaviour_preference == "oneHandedPreference" ~ "One Handed Gesture",
      behaviour_preference == "twoHandedPreference" ~ "Two Handed Gesture",
      behaviour_preference == "noPreference" ~ "No Preference",
      TRUE ~ behaviour_preference
    )
  ) %>%
  group_by(UserID) %>%
  summarise(
    behaviour_preference = first(behaviour_preference),
    behaviour_feedback = first(behaviour_feedback),
    .groups = "drop"
  )

kable(data.rotating.preference.summary, caption = "User Feedback Summary - Rotating")
```

###### Summary

### Study: Scale

#### Scale Data Preparation

```{r Scale Data Preparation}
data.scale <- data %>%
  mutate(scaleCondition = if_else(moveGlobeWhileScaling, "movingGlobe", "nonMovingGlobe")) %>%
  select(-moveGlobeWhileScaling) %>%
  inner_join(demographic, by = "UserID") %>%
  inner_join(scale_MG, by = "UserID") %>%
    rename(
    PAAS_MG = Mentally_demanding,
    BORG_MG = Physically_demanding
  ) %>%
  mutate(
    PAAS_MG = as.numeric(str_extract(PAAS_MG, "\\d+(\\.\\d+)?")),
    BORG_MG = as.numeric(str_extract(BORG_MG, "\\d+(\\.\\d+)?"))
  ) %>%
  mutate(
    PAAS_MG = if_else(scaleCondition == "movingGlobe", PAAS_MG, NA_real_),
    BORG_MG = if_else(scaleCondition == "movingGlobe", BORG_MG, NA_real_)
  ) %>%
  inner_join(scale_NMG, by = "UserID") %>%
  rename(
    PAAS_NMG = Mentally_demanding,
    BORG_NMG = Physically_demanding
  ) %>%
  mutate(
    PAAS_NMG = as.numeric(str_extract(PAAS_NMG, "\\d+(\\.\\d+)?")),
    BORG_NMG = as.numeric(str_extract(BORG_NMG, "\\d+(\\.\\d+)?"))
  ) %>%
  mutate(
    PAAS_NMG = if_else(scaleCondition == "nonMovingGlobe", PAAS_NMG, NA_real_),
    BORG_NMG = if_else(scaleCondition == "nonMovingGlobe", BORG_NMG, NA_real_)
  ) %>%
  inner_join(scale_preference, by = "UserID") %>%
  rename(
    behaviour_preference = Scale_preference,
    behaviour_feedback = Scale_feedback
  ) %>%
  mutate(
    behaviour_preference = case_when(
    str_detect(behaviour_preference, "Maintain distance") ~ "maintainDistance",
    str_detect(behaviour_preference, "Maintain globe") ~ "maintainGlobe",
    str_detect(behaviour_preference, "no preference") ~ "noPreference",
    TRUE ~ "unknown"
  )) %>%
  filter(Type == "scaleTask") %>%
  select(UserID, TaskID, ActionID, scaleCondition, zoomDirection, Date, ActionStatus, main_scale_x,
  main_scale_y, main_scale_z, target_scale_x, target_scale_y, target_scale_z, match_accuracy_result, status,
  PAAS_MG, BORG_MG, PAAS_NMG, BORG_NMG, behaviour_preference, behaviour_feedback) %>%
  mutate(zoomDirection = as.factor(zoomDirection), 
         scaleCondition = as.factor(scaleCondition),
         status = as.factor(status),
         behaviour_preference = as.factor(behaviour_preference))

```

#### Scale Task Study

##### Accuracy

###### Normality

```{r Scale Task Study - Accuracy - Normality}

data.scale.matched <- data.scale %>%
  filter(status == "Matched")

shapiro.test(data.scale.matched$match_accuracy_result)

hist(data.scale.matched$match_accuracy_result, breaks = 100,
     main = "Histogram (Zoomed)", xlab = "Accuracy",
     col = "lightblue", xlim = c(0, 0.5))

plot(density(data.scale.matched$match_accuracy_result), 
     main = "Density Plot (Zoomed)", xlab = "Accuracy",
     col = "blue", lwd = 2, xlim = c(0, 0.5))

# Although the w value is close to 1, the p value is below 0.05 so we reject null hypothesis that the data is normally distributed
# So, we cannot use one way ANOVA, instead, we use Wilcoxon signed-rank test
```

###### Statistical tests 

```{r Scale Task Study - Accuracy - Statistical Tests}
data.scale.matched.accuracy_avg.long <- data.scale.matched %>%
  group_by(UserID, scaleCondition, zoomDirection) %>%
  summarise(mean_accuracy = mean(match_accuracy_result, na.rm = TRUE), .groups = 'drop')

data.scale.matched.art <- art(mean_accuracy ~ scaleCondition * zoomDirection + (1|UserID), data = data.scale.matched.accuracy_avg.long)

anova(data.scale.matched.art)

# •	The main effect of scaleCondition on mean accuracy was not significant, F(1, 33) = 0.55, p = 0.464.
# •	The main effect of zoomDirection was also not significant, F(1, 33) = 0.51, p = 0.478.
# •	The interaction between scaleCondition and zoomDirection was not significant either, F(1, 33) = 0.95, p = 0.336.

# There were no statistically significant effects of either scale condition, zoom direction, or their interaction on mean accuracy. This suggests that participants’ accuracy was not influenced by how the globe was scaled or zoomed, nor by the combination of these two factors.

ggplot(data.scale.matched.accuracy_avg.long, aes(x = scaleCondition, y = mean_accuracy, group = UserID)) +
  geom_line(aes(color = as.factor(UserID)), linewidth = 1, alpha = 0.6) +
  geom_point(size = 3) +
  facet_wrap(~ zoomDirection) + 
  labs(title = "Paired Accuracy by Globe Behaviour and Zoom Direction",
       x = "Behaviour",
       y = "Match Accuracy",
      color = "UserID") +
  theme_minimal() +
  theme(strip.text = element_text(size = 12, face = "bold"))

ggplot(data.scale.matched.accuracy_avg.long, aes(x = scaleCondition, y = mean_accuracy)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  facet_wrap(~ zoomDirection) + 
  labs(title = "Boxplots of Accuracy by Globe Movement Behaviour",
       x = "Behaviour",
       y = "Match Accuracy") +
  theme_minimal()
```

##### Completion Time

###### Normality

```{r Scale Task Study - Completion Time - Normality}
data.scale.taskCompletion_avg <- data.scale %>%
  group_by(UserID, TaskID) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  )

shapiro.test(data.scale.taskCompletion_avg$completion_time)
```

###### Statistical Tests

```{r Scale Task Study - Completion Time - Statistical Tests}

data.scale.taskCompletion_avg.long <- data.scale %>%
  group_by(UserID, scaleCondition, TaskID, zoomDirection) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  group_by(UserID, scaleCondition, zoomDirection) %>%
  summarise(
    avg_completion_time = mean(completion_time),
    .groups = "drop"
  ) 

data.scale.taskCompletion.art <- art(avg_completion_time ~ scaleCondition * zoomDirection + (1|UserID), data = data.scale.taskCompletion_avg.long)

anova(data.scale.matched.art)

# scaleCondition F-value 0.549 P-value 0.464 means not significant
# zoomDirection F-value 0.514 P-value 0.478 means Not significant
# scaleCondition:zoomDirection (Interaction) F-value 0.953 Not significant

# The analysis revealed no statistically significant effects of scaleCondition, zoomDirection, or their interaction on mean accuracy. All p-values are well above the common alpha level of 0.05, indicating that neither the type of scaling nor the zoom direction had a meaningful impact on participants’ accuracy. Additionally, the lack of a significant interaction suggests that the combined effect of scaling and zoom direction does not influence accuracy either.


ggplot(data.scale.taskCompletion_avg.long, aes(x = scaleCondition, y = avg_completion_time, group = UserID)) +
  geom_line(aes(color = as.factor(UserID)), linewidth = 1, alpha = 0.6) +
  geom_point(size = 3) +
  facet_wrap(~ zoomDirection) + 
  labs(
    title = "Paired Task Completion Time by Behaviour and Zoom Direction",
    x = "Behaviour",
    y = "Completion Time (minutes)",
    color = "UserID"
  ) +
  theme_minimal()

ggplot(data.scale.taskCompletion_avg.long, aes(x = scaleCondition, y = avg_completion_time)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  facet_wrap(~ zoomDirection) + 
  labs(title = "Boxplots of Task Completion Time by Globe's Behaviour and Zoom Direction",
       x = "Behaviour",
       y = "Task Completion Time") +
  theme_minimal()
```


##### Subjective Measures

###### Physical and Mental Exertion

```{r Scale - Physical and Mental Exertion}
data.scale.long <- data.scale %>% 
  select(UserID, scaleCondition, PAAS_MG, BORG_MG, PAAS_NMG, BORG_NMG) %>%
  distinct() %>%
  pivot_longer(
    cols = c(PAAS_MG, BORG_MG, PAAS_NMG, BORG_NMG),
    names_to = "Measure",
    values_to = "Score"
  ) %>%
  filter(!is.na(Score)) %>%  
  mutate(
    ExertionType = case_when(
      str_detect(Measure, "PAAS") ~ "Cognitive load",
      str_detect(Measure, "BORG") ~ "Physical exertion",
      TRUE ~ "Unknown"
    ),
    UserID = as.factor(UserID),
    ExertionType = as.factor(ExertionType)
  ) %>%
  group_by(UserID, scaleCondition, Measure)
  
data.scale.long.art_anova <- art(Score ~ scaleCondition * ExertionType + (1|UserID), data = data.scale.long)
anova(data.scale.long.art_anova)

# 	•	Main effect of scaleCondition: F(1, 33) = 1.36, p = 0.2521 Not statistically significant. This suggests that the scaling condition (e.g. scaled vs not scaled globe) did not have a meaningful effect on exertion scores overall. 
#  	•	Main effect of ExertionType: F(1, 33) = 55.27, p < 0.001 → Highly significant. This shows a strong difference between cognitive load (PAAS) and physical exertion (BORG) scores, regardless of the scale condition.
# 	•	Interaction (scaleCondition × ExertionType): F(1, 33) = 0.084, p = 0.7735. This means the difference between PAAS and BORG scores does not vary depending on whether scaling was involved.
# Only the type of exertion (cognitive vs physical) had a significant impact on participant scores. The scale condition had no effect, nor did it change the relationship between exertion types. Participants consistently rated cognitive and physical exertion differently, but this pattern was stable across both scaled and non-scaled conditions.

ggplot(data.scale.long, aes(x = scaleCondition, y = Score, fill = ExertionType)) +
  geom_boxplot(width = 0.1, position = position_dodge(0.8)) +
  labs(
    x = "Scale Condition",
    y = "Score",
    title = "Distribution of Scores by Behaviour and Exertion Type"
  ) +
  theme_minimal()

```

###### Preference

```{r Scale - Preference}
data.scale %>%
  select(UserID, behaviour_preference) %>%
  distinct() %>%  
  count(behaviour_preference) %>%
  mutate(
    percent = n / sum(n),
    ncount = paste0(n, "\n", percent_format()(percent))
  ) %>%
  ggplot(aes(x = "", y = n, fill = behaviour_preference)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = ncount), position = position_stack(vjust = 0.5), size = 4) +
  labs(
    title = "Distribution of Scale Behaviour Preferences",
    fill = "Preference"
  ) +
  theme_void()
```

###### Comments

```{r Scale - Comments}
data.scale.preference.summary <- data.scale %>%
  mutate(
    behaviour_preference = case_when(
      behaviour_preference == "maintainDistance" ~ "Maintain Globe's Distance",
      behaviour_preference == "maintainGlobe" ~ "Maintain Globe's Position",
      behaviour_preference == "noPreference" ~ "No Preference",
      TRUE ~ behaviour_preference
    )
  ) %>%
  group_by(UserID) %>%
  summarise(
    behaviour_preference = first(behaviour_preference),
    behaviour_feedback = first(behaviour_feedback),
    .groups = "drop"
  )

kable(data.scale.preference.summary, caption = "User Feedback Summary - Scale")
```

###### Summary

---
title: "Gestures for Positioning, Scaling, and Rotating Virtual Globes"
author: "Faisal Agung Abdillah"
date: "2025-05-08"
output:
  html_document:
    code_folding: show
    toc: true
    toc_float: true
    toc_depth: 6
    theme: flatly
    highlight: haddock
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Gestures for Globes Research

## Data and Libraries Load

```{r}
library(tidyverse)
library(dplyr)
library(car)
library(ggplot2)
library(lubridate)
library(scales)
library(ARTool)
library(knitr)
library(kableExtra)

data <- read_csv("study_tasks.csv")
demographic <- read_csv("final_introductory.csv")
positioning_NRG <- read_csv("final_positioning_NRG.csv")
positioning_RG <- read_csv("final_positioning_RG.csv")
positioning_preference <- read_csv("final_positioning_comparison.csv")
rotation_OH <- read_csv("final_rotation_OH.csv")
rotation_TH <- read_csv("final_rotation_TH.csv")
rotation_preference <- read_csv("final_rotation_comparison.csv")
scale_MG <- read_csv("final_scale_MG.csv")
scale_NMG <- read_csv("final_scale_NMG.csv")
scale_preference <- read_csv("final_scale_comparison.csv")
combined_preference <- read_csv("final_outro_comparison.csv")

summary(data)

summary(demographic)

summary(positioning_NRG)

summary(positioning_RG)

summary(positioning_preference)

summary(rotation_OH)

summary(rotation_TH)

summary(rotation_preference)

summary(scale_MG)

summary(scale_NMG)

summary(scale_preference)

summary(combined_preference)
```

## General Data Preparation & Restructuring

Restructure the data for better analysis

```{r Data - restructure}

# Positioning

data.positioning.accuracy <- data %>%
  filter(Type == "positionTask") %>%
  select(UserID, TaskID, rotateGlobeWhileDragging, match_accuracy_result, status) %>%
  filter(status == "Matched") %>%
  select(-status) %>%
  mutate(Technique = if_else(rotateGlobeWhileDragging, "rotatingGlobe", "nonRotatingGlobe")) %>%
  select(-rotateGlobeWhileDragging) %>%
  rename("Accuracy" = "match_accuracy_result")
  
data.positioning.time <- data %>%
  filter(Type == "positionTask") %>%
  select(UserID, TaskID, rotateGlobeWhileDragging, Date) %>%
  group_by(UserID, TaskID, rotateGlobeWhileDragging) %>%
  summarise(
    Time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  mutate(Technique = if_else(rotateGlobeWhileDragging, "rotatingGlobe", "nonRotatingGlobe")) %>%
  select(-rotateGlobeWhileDragging)
  
data.positioning.borg <- data %>%
  filter(Type == "positionTask") %>%
  mutate(Technique = if_else(rotateGlobeWhileDragging, "rotatingGlobe", "nonRotatingGlobe")) %>%
  select(UserID, Technique) %>%
  distinct() %>%
  inner_join(positioning_NRG, by = "UserID") %>%
  rename(BORG_NRG = Physically_demanding) %>%
  select(-Timestamp, -Mentally_demanding) %>%
  mutate(BORG_NRG = as.numeric(str_extract(BORG_NRG, "\\d+(\\.\\d+)?"))) %>%
  inner_join(positioning_RG, by = "UserID") %>%
  rename(BORG_RG = Physically_demanding) %>%
  select(-Timestamp, -Mentally_demanding) %>%
  mutate(BORG_RG = as.numeric(str_extract(BORG_RG, "\\d+(\\.\\d+)?"))) %>%
  mutate(
    BORGRPE = if_else(Technique == "rotatingGlobe", BORG_RG, BORG_NRG)
  ) %>%
  select(-BORG_RG, -BORG_NRG)

data.positioning.paas <- data %>%
  filter(Type == "positionTask") %>%
  mutate(Technique = if_else(rotateGlobeWhileDragging, "rotatingGlobe", "nonRotatingGlobe")) %>%
  select(UserID, Technique) %>%
  distinct() %>%
  inner_join(positioning_NRG, by = "UserID") %>%
  rename(PAAS_NRG = Mentally_demanding) %>%
  select(-Timestamp, -Physically_demanding) %>%
  mutate(PAAS_NRG = as.numeric(str_extract(PAAS_NRG, "\\d+(\\.\\d+)?"))) %>%
  inner_join(positioning_RG, by = "UserID") %>%
  rename(PAAS_RG = Mentally_demanding) %>%
  select(-Timestamp, -Physically_demanding) %>%
  mutate(PAAS_RG = as.numeric(str_extract(PAAS_RG, "\\d+(\\.\\d+)?"))) %>%
  mutate(
    PAAS = if_else(Technique == "rotatingGlobe", PAAS_RG, PAAS_NRG)
  ) %>%
  select(-PAAS_RG, -PAAS_NRG)

data.positioning.qualitative <- positioning_preference %>%
  select(-Timestamp) %>%
  mutate(
    Positioning_preference = case_when(
      str_detect(Positioning_preference, "Static orientation") ~ "staticOrientation",
      str_detect(Positioning_preference, "Adaptive orientation") ~ "adaptiveOrientation",
      str_detect(Positioning_preference, "no preference") ~ "noPreference",
      TRUE ~ "unknown"
    ),
    Positioning_preference = as.factor(Positioning_preference)
  )

# Rotating

data.rotating.accuracy <- data %>%
  filter(Type == "rotationTask") %>%
  select(UserID, TaskID, oneHandedRotationGesture, match_accuracy_result, status) %>%
  filter(status == "Matched") %>%
  select(-status) %>%
  mutate(Technique = if_else(oneHandedRotationGesture, "oneHanded", "twoHanded")) %>%
  select(-oneHandedRotationGesture) %>%
  rename("Accuracy" = "match_accuracy_result")

data.rotating.time <- data %>%
  filter(Type == "rotationTask") %>%
  select(UserID, TaskID, oneHandedRotationGesture, Date) %>%
  group_by(UserID, TaskID, oneHandedRotationGesture) %>%
  summarise(
    Time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  mutate(Technique = if_else(oneHandedRotationGesture, "oneHanded", "twoHanded")) %>%
  select(-oneHandedRotationGesture)

data.rotating.borg <- data %>%
  filter(Type == "rotationTask") %>%
  mutate(Technique = if_else(oneHandedRotationGesture, "oneHanded", "twoHanded")) %>%
  select(UserID, Technique) %>%
  distinct() %>%
  inner_join(rotation_OH, by = "UserID") %>%
  rename(BORG_OH = Physically_demanding) %>%
  select(-Timestamp, -Mentally_demanding) %>%
  mutate(BORG_OH = as.numeric(str_extract(BORG_OH, "\\d+(\\.\\d+)?"))) %>%
  inner_join(rotation_TH, by = "UserID") %>%
  rename(BORG_TH = Physically_demanding) %>%
  select(-Timestamp, -Mentally_demanding) %>%
  mutate(BORG_TH = as.numeric(str_extract(BORG_TH, "\\d+(\\.\\d+)?"))) %>%
  mutate(
    BORGRPE = if_else(Technique == "oneHanded", BORG_OH, BORG_TH)
  ) %>%
  select(-BORG_OH, -BORG_TH)

data.rotating.paas <- data %>%
  filter(Type == "rotationTask") %>%
  mutate(Technique = if_else(oneHandedRotationGesture, "oneHanded", "twoHanded")) %>%
  select(UserID, Technique) %>%
  distinct() %>%
  inner_join(rotation_OH, by = "UserID") %>%
  rename(PAAS_OH = Mentally_demanding) %>%
  select(-Timestamp, -Physically_demanding) %>%
  mutate(PAAS_OH = as.numeric(str_extract(PAAS_OH, "\\d+(\\.\\d+)?"))) %>%
  inner_join(rotation_TH, by = "UserID") %>%
  rename(PAAS_TH = Mentally_demanding) %>%
  select(-Timestamp, -Physically_demanding) %>%
  mutate(PAAS_TH = as.numeric(str_extract(PAAS_TH, "\\d+(\\.\\d+)?"))) %>%
  mutate(
    PAAS = if_else(Technique == "oneHanded", PAAS_OH, PAAS_TH)
  ) %>%
  select(-PAAS_OH, -PAAS_TH)

data.rotating.qualitative <- rotation_preference %>%
  select(-Timestamp) %>%
  mutate(
    Rotation_preference = case_when(
    str_detect(Rotation_preference, "One-handed") ~ "oneHandedPreference",
    str_detect(Rotation_preference, "Two-handed") ~ "twoHandedPreference",
    str_detect(Rotation_preference, "no preference") ~ "noPreference",
    TRUE ~ "unknown"
    ),   
    Rotation_preference = as.factor(Rotation_preference)
  ) 

# Scale

data.scale.accuracy <- data %>%
  filter(Type == "scaleTask") %>%
  select(UserID, TaskID, moveGlobeWhileScaling, match_accuracy_result, status) %>%
  filter(status == "Matched") %>%
  select(-status) %>%
  mutate(Technique = if_else(moveGlobeWhileScaling, "movingGlobe", " nonMovingGlobe")) %>%
  select(-moveGlobeWhileScaling) %>%
  rename("Accuracy" = "match_accuracy_result")

data.scale.time <- data %>%
  filter(Type == "scaleTask") %>%
  select(UserID, TaskID, moveGlobeWhileScaling, Date) %>%
  group_by(UserID, TaskID, moveGlobeWhileScaling) %>%
  summarise(
    Time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  mutate(Technique = if_else(moveGlobeWhileScaling, "movingGlobe", "nonMovingGLobe")) %>%
  select(-moveGlobeWhileScaling)

data.scale.borg <- data %>%
  filter(Type == "scaleTask") %>%
  mutate(Technique = if_else(moveGlobeWhileScaling, "movingGlobe", "nonMovingGlobe")) %>%
  select(UserID, Technique) %>%
  distinct() %>%
  inner_join(scale_NMG, by = "UserID") %>%
  rename(BORG_NMG = Physically_demanding) %>%
  select(-Timestamp, -Mentally_demanding) %>%
  mutate(BORG_NMG = as.numeric(str_extract(BORG_NMG, "\\d+(\\.\\d+)?"))) %>%
  inner_join(scale_MG, by = "UserID") %>%
  rename(BORG_MG = Physically_demanding) %>%
  select(-Timestamp, -Mentally_demanding) %>%
  mutate(BORG_MG = as.numeric(str_extract(BORG_MG, "\\d+(\\.\\d+)?"))) %>%
  mutate(
    BORGRPE = if_else(Technique == "movingGlobe", BORG_MG, BORG_NMG)
  ) %>%
  select(-BORG_MG, -BORG_NMG)

data.scale.paas <- data %>%
  filter(Type == "scaleTask") %>%
  mutate(Technique = if_else(moveGlobeWhileScaling, "movingGlobe", "nonMovingGlobe")) %>%
  select(UserID, Technique) %>%
  distinct() %>%
  inner_join(scale_NMG, by = "UserID") %>%
  rename(PAAS_NMG = Mentally_demanding) %>%
  select(-Timestamp, -Physically_demanding) %>%
  mutate(PAAS_NMG = as.numeric(str_extract(PAAS_NMG, "\\d+(\\.\\d+)?"))) %>%
  inner_join(scale_MG, by = "UserID") %>%
  rename(PAAS_MG = Mentally_demanding) %>%
  select(-Timestamp, -Physically_demanding) %>%
  mutate(PAAS_MG = as.numeric(str_extract(PAAS_MG, "\\d+(\\.\\d+)?"))) %>%
  mutate(
    PAAS = if_else(Technique == "movingGlobe", PAAS_MG, PAAS_NMG)
  ) %>%
  select(-PAAS_MG, -PAAS_NMG)

data.scale.qualitative <- scale_preference %>%
  select(-Timestamp) %>%
  mutate(
    Scale_preference = case_when(
    str_detect(Scale_preference, "Maintain distance") ~ "maintainDistance",
    str_detect(Scale_preference, "Maintain globe") ~ "maintainGlobe",
    str_detect(Scale_preference, "no preference") ~ "noPreference",
    TRUE ~ "unknown"
    ),
    Scale_preference = as.factor(Scale_preference)
  ) 

# Combined qualitative

data.combined.qualitative <- combined_preference %>%
  select(-Timestamp) %>%
  rename(
    Positioning_preference = Combined_positioning_preference,
    Rotation_preference = Combined_rotation_preference,
    Scale_preference = Combined_scale_preference
  ) %>%
  mutate(
    Positioning_preference = case_when(
      str_detect(Positioning_preference, "Static orientation") ~ "staticOrientation",
      str_detect(Positioning_preference, "Adaptive orientation") ~ "adaptiveOrientation",
      str_detect(Positioning_preference, "No preference") ~ "noPreference",
      TRUE ~ "unknown"
    ),
    Positioning_preference = as.factor(Positioning_preference)
  ) %>%
  mutate(
    Rotation_preference = case_when(
    str_detect(Rotation_preference, "One-handed") ~ "oneHandedPreference",
    str_detect(Rotation_preference, "Two-handed") ~ "twoHandedPreference",
    str_detect(Rotation_preference, "No preference") ~ "noPreference",
    TRUE ~ "unknown"
    ),
    Rotation_preference = as.factor(Rotation_preference)
  ) %>%
  mutate(
    Scale_preference = case_when(
    str_detect(Scale_preference, "Maintain distance") ~ "maintainDistance",
    str_detect(Scale_preference, "Maintain globe") ~ "maintainGlobe",
    str_detect(Scale_preference, "No preference") ~ "noPreference",
    TRUE ~ "unknown"
    ),
    Scale_preference = as.factor(Scale_preference)
  )

```


## Participants Demographic Information


```{r Demographic}
# Total number of participants
length(unique(data$UserID))

# Participants' gender distribution
demographic.gender <-  demographic %>%
  select(UserID, Gender) %>%
  distinct() %>%
  group_by(Gender) %>%
  summarise(count = n()) %>%
  mutate(percentage = round(count / sum(count) * 100, 1), percentage = paste0(percentage, "%"))

demographic.gender

# Participants' gender distribution chart
ggplot(demographic.gender, aes(x = "", y = count, fill = Gender)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = percentage), position = position_stack(vjust = 0.5), size = 4) +
  labs(title = "Distribution of Participants' Gender") +
  theme_void()

# Participants' academic level distribution
demographic.academic_level <-  demographic %>%
  select(UserID, Academic_level) %>%
  distinct() %>%
  group_by(Academic_level) %>%
  summarise(count = n()) %>%
  mutate(percentage = round(count / sum(count) * 100, 1), graph_label = paste0(percentage, "%")) %>%
  rename(`Academic levels` = Academic_level)

demographic.academic_level

# Participants' academic level distribution chart
ggplot(demographic.academic_level, aes(x = "", y = count, fill = `Academic levels`)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = graph_label), position = position_stack(vjust = 0.5), size = 4) +
  labs(title = "Distribution of Participants' Academic Level") +
  theme_void() 

# Participants' previous AR/VR experience distribution
demographic.ARVR_exp <-  demographic %>%
  select(UserID, Exp_ARVR ) %>%
  distinct() %>%
  group_by(Exp_ARVR) %>%
  summarise(count = n()) %>%
  mutate(percentage = round(count / sum(count) * 100, 1), 
         label = paste0(percentage, "%"),
         ShortLabel = fct_recode(Exp_ARVR,
                          "No experience" = "I have no experience")
) %>%
  rename(`Previous AR/VR experience` = ShortLabel)

demographic.ARVR_exp

# Participants' previous AR/VR experience distribution chart
ggplot(demographic.ARVR_exp, aes(x = "", y = count, fill = `Previous AR/VR experience`)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = label), position = position_stack(vjust = 0.5), size = 4) +
  labs(title = "Distribution of Participants Previous AR/VR Experience") +
  theme_void() 

# Participants' previous globe experience distribution
demographic.globes_exp <- demographic %>%
  select(UserID, Globe_usage_frequency) %>%
  distinct() %>%
  group_by(Globe_usage_frequency) %>%
  summarise(count = n()) %>%
  mutate(percentage = round(count / sum(count) * 100, 1),
         graph_label = paste0(percentage, "%")) %>%
  rename(`Previous globes experience` = Globe_usage_frequency)

demographic.globes_exp

# Participants' previous globe experience distribution chart
ggplot(demographic.globes_exp, aes(x = "", y = count, fill = `Previous globes experience`)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = graph_label), position = position_stack(vjust = 0.5), size = 4) +
  labs(title = "Distribution of Participants Previous AR/VR Experience") +
  theme_void() 

# Participants' previous Apple Vision Pro Experience distribution
demographic.visionpro_exp <- demographic %>%
  select(UserID, Have_used_VisionPro) %>%
  distinct() %>%
  group_by(Have_used_VisionPro) %>%
  summarise(count = n()) %>%
  mutate(
    percentage = round(count / sum(count) * 100, 1),
    graph_label = paste0(percentage, "%")
  ) %>%
  rename(`Have used Apple Vision Pro` = Have_used_VisionPro)
  
demographic.visionpro_exp
  
# Participants' previous Apple Vision Pro Experience distribution chart
ggplot(demographic.visionpro_exp, aes(x = "", y = count, fill = `Have used Apple Vision Pro`)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = graph_label), position = position_stack(vjust = 0.5), size = 4) +
  labs(title = "Distribution of Participants Previous AR/VR Experience") +
  theme_void()   

```

## User Study

### Study: Positioning

#### Positioning Data Preparation

```{r Positioning Data Preparation}
data.positioning <- data %>%
  mutate(positionCondition = if_else(rotateGlobeWhileDragging, "rotatingGlobe", "nonRotatingGlobe")) %>%
  select(-rotateGlobeWhileDragging) %>%
  inner_join(demographic, by = "UserID") %>%
  inner_join(positioning_NRG, by = "UserID") %>%
  rename(
    PAAS_NRG = Mentally_demanding,
    BORG_NRG = Physically_demanding
  ) %>%
  mutate(
    PAAS_NRG = as.numeric(str_extract(PAAS_NRG, "\\d+(\\.\\d+)?")),
    BORG_NRG = as.numeric(str_extract(BORG_NRG, "\\d+(\\.\\d+)?"))
  ) %>%
  mutate(
    PAAS_NRG = if_else(positionCondition == "nonRotatingGlobe", PAAS_NRG, NA_real_),
    BORG_NRG = if_else(positionCondition == "nonRotatingGlobe", BORG_NRG, NA_real_)
  ) %>%
  inner_join(positioning_RG, by = "UserID") %>%
  rename(
    PAAS_RG = Mentally_demanding,
    BORG_RG = Physically_demanding
  ) %>%
  mutate(
    PAAS_RG = as.numeric(str_extract(PAAS_RG, "\\d+(\\.\\d+)?")),
    BORG_RG = as.numeric(str_extract(BORG_RG, "\\d+(\\.\\d+)?"))
  ) %>%
  mutate(
    PAAS_RG = if_else(positionCondition == "rotatingGlobe", PAAS_RG, NA_real_),
    BORG_RG = if_else(positionCondition == "rotatingGlobe", BORG_RG, NA_real_)
  ) %>%
  inner_join(positioning_preference, by = "UserID") %>%
  rename(
    behaviour_preference = Positioning_preference,
    behaviour_feedback = Positioning_feedback
  ) %>%
  mutate(
      behaviour_preference = case_when(
    str_detect(behaviour_preference, "Static orientation") ~ "staticOrientation",
    str_detect(behaviour_preference, "Adaptive orientation") ~ "adaptiveOrientation",
    str_detect(behaviour_preference, "no preference") ~ "noPreference",
    TRUE ~ "unknown"
  ) ) %>%
  filter(Type == "positionTask") %>%
  select(UserID, TaskID, ActionID, positionCondition, distance, direction, Date, ActionStatus, main_translation_x,
  main_translation_y, main_translation_z, target_translation_x, target_translation_y, target_translation_z, 
  match_accuracy_result, status, PAAS_NRG, BORG_NRG, PAAS_RG, BORG_RG, behaviour_preference, behaviour_feedback) %>%
  mutate(distance = as.factor(distance), 
         direction = as.factor(direction), 
         positionCondition = as.factor(positionCondition),
         status = as.factor(status),
         behaviour_preference = as.factor(behaviour_preference))

```

#### Position Task Study

##### Accuracy

###### Normality

```{r PositionStudy - Accuracy - Normality}

shapiro.test(data.positioning.accuracy$Accuracy)

hist(data.positioning.accuracy$Accuracy, breaks = 100,
     main = "Histogram of Positioning Gestures Accuracy", xlab = "Accuracy",
     col = "lightblue", xlim = c(0, 0.06))

plot(density(data.positioning.accuracy$Accuracy), 
     main = "Density Plot of Positioning Gestures Accuracy", xlab = "Accuracy",
     col = "blue", lwd = 2, xlim = c(0, 0.08))
```

Although the w value is close to 1, the p value is below 0.05 so we reject null hypothesis that the data is normally distributed
So, we cannot use one way ANOVA, instead, we use ART ANOVA test

###### Statistical Tests

```{r PositionStudy - Accuracy - Statistical tests}


data.positioning.matched <- data.positioning %>%
  filter(status == "Matched")

data.positioning.matched.accuracy_avg.long <- data.positioning.matched %>%
  group_by(UserID, positionCondition, distance, direction) %>%
  summarise(mean_accuracy = mean(match_accuracy_result, na.rm = TRUE), .groups = 'drop')

data.positioning.matched.art <- art(mean_accuracy ~ positionCondition * distance * direction + (1|UserID), data = data.positioning.matched.accuracy_avg.long)

anova(data.positioning.matched.art)

	# •	The main effect of positionCondition was not statistically significant: F(1, 99) = 0.89, p = 0.348.
	# •	The main effect of distance was statistically significant: F(1, 99.55) = 8.58, p = 0.0042 (**).
	# •	The main effect of direction was also statistically significant: F(2, 99.53) = 3.51, p = 0.0335 (*).
	# •	The interaction between positionCondition and distance was not significant: F(1, 99) = 0.88, p = 0.349.
	# •	The interaction between positionCondition and direction was not significant: F(2, 99) = 0.22, p = 0.803.
	# •	The interaction between distance and direction was not significant: F(2, 99.51) = 0.25, p = 0.778.
	# •	The three-way interaction (positionCondition × distance × direction) was not significant: F(2, 99) = 1.62, p = 0.202.

# There were significant main effects of both distance and direction on mean accuracy, indicating that participants’ accuracy was influenced independently by how far the task was and from which direction it came. However, positionCondition had no significant effect, and no interaction terms reached statistical significance. This suggests that the combined effects of position, distance, and direction do not differentially impact accuracy beyond the main effects of distance and direction alone.

# Plotting for position behaviours
data.positioning.matched.accuracy_avg.long %>%
  group_by(positionCondition) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(positionCondition = case_when(
    positionCondition == "rotatingGlobe" ~ "Rotating Globe",
    positionCondition == "nonRotatingGlobe" ~ "Non Rotating Globe",
    TRUE ~ as.character(positionCondition))) %>%
  ggplot(aes(x = positionCondition, y = mean_mean_accuracy, fill = positionCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci), width = 0.2) +
  labs(
    title = "Mean Match Accuracy by Globe Behaviour",
    x = "Globe Behaviour",
    y = "Mean Accuracy",
    fill = "Globe Behaviour"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank())

# Plotting for distance conditions
data.positioning.matched.accuracy_avg.long %>%
  group_by(distance) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  ggplot(aes(x = distance, y = mean_mean_accuracy, fill = distance)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci), width = 0.2) +
  labs(
    title = "Mean Match Accuracy by Globe Distance",
    x = "Globe Distance",
    y = "Mean Accuracy",
    fill = "Globe Distance"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank())

# Plotting for direction conditions
data.positioning.matched.accuracy_avg.long %>%
  group_by(direction) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  ggplot(aes(x = direction, y = mean_mean_accuracy, fill = direction)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci), width = 0.2) +
  labs(
    title = "Mean Match Accuracy by Globe Direction",
    x = "Globe Direction",
    y = "Mean Accuracy",
    fill = "Globe Direction"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank())

# Plotting for both Position Conditions and Behaviours
data.positioning.matched.accuracy_avg.long %>%
  group_by(positionCondition, distance, direction) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(positionCondition = case_when(
    positionCondition == "rotatingGlobe" ~ "Rotating Globe",
    positionCondition == "nonRotatingGlobe" ~ "Non Rotating Globe",
    TRUE ~ as.character(positionCondition))) %>%
  ggplot(aes(x = positionCondition, y = mean_mean_accuracy, fill = positionCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci),
                width = 0.2) +
  facet_wrap(~ distance + direction) +
  labs(
    title = "Mean Match Accuracy by Globe Behaviour, Distance, and Direction",
    x = "Globe Positioning Behaviour",
    y = "Mean Accuracy",
    fill = "Globe Positioning Behaviour"
  ) +
  theme_minimal() +
    theme(
    axis.text.x = element_blank()
  )

# Boxplots for globe behaviour and conditions

ggplot(data.positioning.matched.accuracy_avg.long, aes(x = positionCondition, y = mean_accuracy)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  facet_wrap(~ distance + direction) + 
  labs(title = "Boxplots of Accuracy by Globe Behaviour, Globes' Distance and Direction",
       x = "Behaviour",
       y = "Match Accuracy") +
  theme_minimal()
```

##### Completion Time

###### Normality

```{r PositionStudy - Completion Time - Normality}

shapiro.test(data.positioning.time$Time)

hist(data.positioning.time$Time, breaks = 100,
     main = "Histogram of Positioning Gestures Task Completion Time", xlab = "Completion Time",
     col = "lightblue", xlim = c(0, 1))

plot(density(data.positioning.time$Time), 
     main = "Density Plot of Positioning Gestures Task Completion Time", xlab = "Completion Time",
     col = "blue", lwd = 2, xlim = c(0, 1))

```

###### Statistical Tests

```{r PositionStudy - Completion Time - Statistical Tests}

data.positioning.taskCompletion_avg.long <- data.positioning %>%
  group_by(UserID, positionCondition, TaskID, distance, direction) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  group_by(UserID, positionCondition, distance, direction) %>%
  summarise(
    avg_completion_time = mean(completion_time),
    .groups = "drop"
  )

data.positioning.taskCompletion_avg.art <- art(avg_completion_time ~ positionCondition * distance * direction + (1|UserID), data = data.positioning.taskCompletion_avg.long)

anova(data.positioning.taskCompletion_avg.art)

# •	positionCondition had no significant effect on average task completion time:F(1, 99.00) = 0.61, p = 0.435
# •	distance also showed no significant effect:F(1, 100.62) = 1.75, p = 0.189
# •	direction showed a statistically significant main effect:F(2, 100.86) = 6.39, p = 0.0024 (**), suggesting direction influences how long tasks take
# •	The interaction between positionCondition and distance was not significant:F(1, 99.00) = 0.24, p = 0.624
# •	The interaction between positionCondition and direction was not significant:F(2, 99.00) = 0.50, p = 0.605
# •	The interaction between distance and direction was not significant:F(2, 100.71) = 0.57, p = 0.565
# •	The three-way interaction (positionCondition × distance × direction) was also not significant:F(2, 99.00) = 0.44, p = 0.647
# 
# Only direction had a statistically significant effect on average task completion time, indicating that the direction from which the task was approached meaningfully influenced how long participants took to complete it. Other factors—positionCondition, distance, and all interaction terms—did not have significant effects. This suggests that regardless of position or distance, direction alone may account for differences in task completion time in this context.

# Plotting for positioning behaviour
data.positioning.taskCompletion_avg.long %>%
  group_by(positionCondition) %>%
  summarise(
    mean_mean_time = mean(avg_completion_time, na.rm = TRUE),
    se = sd(avg_completion_time, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(positionCondition = case_when(
    positionCondition == "rotatingGlobe" ~ "Rotating Globe",
    positionCondition == "nonRotatingGlobe" ~ "Non Rotating Globe",
    TRUE ~ as.character(positionCondition))) %>%
  ggplot(aes(x = positionCondition, y = mean_mean_time, fill = positionCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_time - ci, ymax = mean_mean_time + ci), width = 0.2) +
  labs(
    title = "Mean Match Accuracy by Globe Behaviour",
    x = "Globe Behaviour",
    y = "Average Completion Time",
    fill = "Globe Behaviour"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank())

# Plotting for distance factors
data.positioning.taskCompletion_avg.long %>%
  group_by(distance) %>%
  summarise(
    mean_mean_time = mean(avg_completion_time, na.rm = TRUE),
    se = sd(avg_completion_time, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  ggplot(aes(x = distance, y = mean_mean_time, fill = distance)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_time - ci, ymax = mean_mean_time + ci), width = 0.2) +
  labs(
    title = "Mean Match Accuracy by Globe Distance Factors",
    x = "Globe Distance",
    y = "Average Completion Time",
    fill = "Globe Distance"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank())

# Plotting for direction factors
data.positioning.taskCompletion_avg.long %>%
  group_by(direction) %>%
  summarise(
    mean_mean_time = mean(avg_completion_time, na.rm = TRUE),
    se = sd(avg_completion_time, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  ggplot(aes(x = direction, y = mean_mean_time, fill = direction)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_time - ci, ymax = mean_mean_time + ci), width = 0.2) +
  labs(
    title = "Mean Match Accuracy by Globe Direction Factors",
    x = "Globe Direction",
    y = "Average Completion Time",
    fill = "Globe Direction"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank())

# Plotting for both Position Factors and Technique
data.positioning.taskCompletion_avg.long %>%
  group_by(positionCondition, distance, direction) %>%
  summarise(
    mean_mean_time = mean(avg_completion_time, na.rm = TRUE),
    se = sd(avg_completion_time, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(positionCondition = case_when(
    positionCondition == "rotatingGlobe" ~ "Rotating Globe",
    positionCondition == "nonRotatingGlobe" ~ "Non Rotating Globe",
    TRUE ~ as.character(positionCondition))) %>%
  ggplot(aes(x = positionCondition, y = mean_mean_time, fill = positionCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_time - ci, ymax = mean_mean_time + ci),
                width = 0.2) +
  facet_wrap(~ distance + direction) +
  labs(
    title = "Mean Match Accuracy by Globe Behaviour, Distance, and Direction Factors",
    x = "Globe Positioning Behaviour",
    y = "Average Completion Time",
    fill = "Globe Positioning Behaviour"
  ) +
  theme_minimal() +
    theme(
    axis.text.x = element_blank()
  )

# Boxplots for Globe Behaviour, Distance, and Direction Factors

ggplot(data.positioning.taskCompletion_avg.long, aes(x = positionCondition, y = avg_completion_time)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  facet_wrap(~ distance + direction) + 
  labs(title = "Boxplots of Task Completion Time by Behaviour, Distance, and Directio",
       x = "Behaviour",
       y = "Task Completion Time") +
  theme_minimal()

```


##### Subjective Measures

###### Physical and Mental Exertion

```{r Subjective Measures - Physical and Mental Exertion}

data.positioning.combined_exertion <- data.positioning.paas %>%
  full_join(data.positioning.borg, by = c("UserID", "Technique")) %>%
  pivot_longer(
    cols = c(PAAS, BORGRPE),
    names_to = "Measure",
    values_to = "Score"
  ) %>%
  mutate(
    Measure = case_when(
      Measure == "PAAS" & Technique == "rotatingGlobe" ~ "PAAS_RG",
      Measure == "PAAS" & Technique == "nonRotatingGlobe" ~ "PAAS_NRG",
      Measure == "BORGRPE" & Technique == "rotatingGlobe" ~ "BORG_RG",
      Measure == "BORGRPE" & Technique == "nonRotatingGlobe" ~ "BORG_NRG",
      TRUE ~ Measure
    ),
    ExertionType = case_when(
      str_detect(Measure, "PAAS") ~ "Cognitive load",
      str_detect(Measure, "BORG") ~ "Physical exertion",
      TRUE ~ "Unknown"
    )
  ) %>%
  select(UserID, Technique, Measure, Score, ExertionType) %>%
  mutate(
    Technique = as.factor(Technique),
    ExertionType = as.factor(ExertionType)
  )

data.positioning.combined_exertion.art_anova <- art(Score ~ Technique * ExertionType + (1|UserID), data = data.positioning.combined_exertion)

anova(data.positioning.combined_exertion.art_anova)

# 	•	Main effect of positionCondition: F(1, 33) = 12.55, p = 0.0012 This is statistically significant, indicating that task positioning condition (e.g., rotating vs non-rotating globe) has a significant effect on the overall exertion score (which includes cognitive load and physical exertion).
#   •	Main effect of ExertionType: F(1, 33) = 12.81, p = 0.0011 Also statistically significant, meaning that there is a clear difference between cognitive load (PAAS) and physical exertion (BORG) scores regardless of the positioning condition.
# 	•	Interaction effect (positionCondition × ExertionType): F(1, 33) = 0.18, p = 0.6774, suggesting that the effect of positioning condition does not depend on the type of exertion, and vice versa. The differences in PAAS and BORG scores are consistent across both positioning conditions.
# Both the positioning condition and type of exertion significantly influence the exertion score independently, but there is no interaction effect. This means that while both factors matter, their effects do not amplify or diminish each other. For example, rotating vs non-rotating globes affects scores, and cognitive vs physical exertion shows distinct levels, but the difference between PAAS and BORG scores remains similar across positioning conditions.

ggplot(data.positioning.combined_exertion, aes(x = Technique, y = Score, fill = ExertionType)) +
  geom_boxplot(width = 0.1, position = position_dodge(0.8)) +
  labs(
    x = "Position Condition",
    y = "Score",
    title = "Distribution of Exertion Scores by Behaviour and Exertion Type"
  ) +
  theme_minimal()

data.positioning.combined_exertion %>%
  group_by(Technique, ExertionType) %>%
  summarise(
    mean_score = mean(Score),
    sd = sd(Score),
    n = n(),
    ci = qt(0.975, df = n - 1) * sd / sqrt(n),
    .groups = "drop"
  ) %>%
  ggplot(aes(x = Technique, y = mean_score, fill = ExertionType)) +
  geom_col(position = position_dodge(width = 0.7), width = 0.6) +
  geom_errorbar(aes(ymin = mean_score - ci, ymax = mean_score + ci),
                position = position_dodge(width = 0.7), width = 0.2) +
  labs(
    x = "Position Technique",
    y = "Mean Score (95% CI)",
    fill = "Exertion Type",
    title = "Mean Score by Position Condition and Exertion Type"
  ) +
  theme_minimal()

```

###### Preference

```{r Positioning - Preference}

data.positioning.qualitative %>%
  count(Positioning_preference) %>%
  mutate(
    percent = n / sum(n),
    ncount = paste0(n, "\n", percent_format()(percent))
  ) %>%
  ggplot(aes(x = "", y = n, fill = Positioning_preference)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = ncount), position = position_stack(vjust = 0.5), size = 4) +
  labs(
    title = "Distribution of Positioning Behaviour Preferences",
    fill = "Preference"
  ) +
  theme_void()


```

###### Comments

```{r Positioning - comments}

data.positioning.qualitative %>%
  mutate(
    Positioning_preference = case_when(
      Positioning_preference == "staticOrientation" ~ "Static Orientation",
      Positioning_preference == "adaptiveOrientation" ~ "Adaptive Orientation",
      Positioning_preference == "noPreference" ~ "No Preference",
      TRUE ~ Positioning_preference
    )
  ) %>%
  rename(
    "Participant ID" = UserID,
    "Positioning Preference" = Positioning_preference,
    "Positioning Feedback" = Positioning_feedback
  ) %>%
  kable(caption = "User Feedback Summary - Positioning", align = "c") %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = FALSE,
    position = "center"
  ) %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#f7f7f7") %>%
  scroll_box(width = "100%", height = "400px")


```

###### Summary

### Study: Rotating

#### Rotating Data Preparation

```{r Rotating Data Preparation}
data.rotating <- data %>%
  mutate(rotationCondition = if_else(oneHandedRotationGesture, "oneHanded", "twoHanded")) %>%
  select(-oneHandedRotationGesture) %>%
  inner_join(demographic, by = "UserID") %>%
  inner_join(rotation_OH, by = "UserID") %>%
  rename(
    PAAS_OH = Mentally_demanding,
    BORG_OH = Physically_demanding
  ) %>%
  mutate(
    PAAS_OH = as.numeric(str_extract(PAAS_OH, "\\d+(\\.\\d+)?")),
    BORG_OH = as.numeric(str_extract(BORG_OH, "\\d+(\\.\\d+)?"))
  ) %>%
  mutate(
    PAAS_OH = if_else(rotationCondition == "oneHanded", PAAS_OH, NA_real_),
    BORG_OH = if_else(rotationCondition == "oneHanded", BORG_OH, NA_real_)
  ) %>%
  inner_join(rotation_TH, by = "UserID") %>%
  rename(
    PAAS_TH = Mentally_demanding,
    BORG_TH = Physically_demanding
  ) %>%
  mutate(
    PAAS_TH = as.numeric(str_extract(PAAS_TH, "\\d+(\\.\\d+)?")),
    BORG_TH = as.numeric(str_extract(BORG_TH, "\\d+(\\.\\d+)?"))
  ) %>%
  mutate(
    PAAS_TH = if_else(rotationCondition == "twoHanded", PAAS_TH, NA_real_),
    BORG_TH = if_else(rotationCondition == "twoHanded", BORG_TH, NA_real_)
  ) %>%
  inner_join(rotation_preference, by = "UserID") %>%
  rename(
    behaviour_preference = Rotation_preference,
    behaviour_feedback = Rotation_feedback
  ) %>%
  mutate(
      behaviour_preference = case_when(
    str_detect(behaviour_preference, "One-handed") ~ "oneHandedPreference",
    str_detect(behaviour_preference, "Two-handed") ~ "twoHandedPreference",
    str_detect(behaviour_preference, "no preference") ~ "noPreference",
    TRUE ~ "unknown"
  )) %>%
  filter(Type == "rotationTask") %>%
  select(UserID, TaskID, ActionID, rotationCondition, complexity, Date, ActionStatus, main_rotation_x,
  main_rotation_y, main_rotation_z, main_rotation_w, target_rotation_x, target_rotation_y, target_rotation_z,
  target_rotation_w,match_accuracy_result, status, PAAS_OH, BORG_OH, PAAS_TH, BORG_TH, behaviour_preference, behaviour_feedback) %>%
  mutate(complexity = as.factor(complexity), 
         rotationCondition = as.factor(rotationCondition),
         status = as.factor(status),
         behaviour_preference = as.factor(behaviour_preference))

```

#### Rotation Task Study

##### Accuracy

###### Normality

```{r Rotation Task Study - Accuracy - Normality}

shapiro.test(data.rotating.accuracy$Accuracy)

hist(data.rotating.accuracy$Accuracy, breaks = 100,
     main = "Histogram of Rotating Gestures Accuracy", xlab = "Accuracy",
     col = "lightblue", xlim = c(0, 0.3))

plot(density(data.rotating.accuracy$Accuracy), 
     main = "Density Plot of Rotating Gestures Accuracy", xlab = "Accuracy",
     col = "blue", lwd = 2, xlim = c(0, 0.4))

```

Although the w value is close to 1, the p value is below 0.05 so we reject null hypothesis that the data is normally distributed
So, we cannot use one way ANOVA, instead, we use Wilcoxon signed-rank test

###### Statistical tests

```{r Rotation Task Study - Accuracy - Statistical Tests}
 
data.rotating.matched <- data.rotating %>%
  filter(status == "Matched")

data.rotating.matched.accuracy_avg.long <- data.rotating.matched %>%
  group_by(UserID, rotationCondition, complexity) %>%
  summarise(mean_accuracy = mean(match_accuracy_result, na.rm = TRUE), .groups = 'drop') 

data.rotating.matched.art <- art(mean_accuracy ~ rotationCondition * complexity + (1|UserID), data = data.rotating.matched.accuracy_avg.long)

anova(data.rotating.matched.art)

	# •	rotationCondition: F(1, 33) = 4.67, p = 0.038 Significant: rotation affects accuracy
	# •	complexity: F(1, 33) = 20.74, p < 0.001 Highly significant: complexity affects accuracy
	# •	rotationCondition × complexity: F(1, 33) = 0.25, p = 0.62 Not significant: no interaction effect

# The ART ANOVA revealed significant main effects of both rotation condition and complexity on accuracy. Rotation condition had a modest but significant effect (p = 0.038), while complexity showed a strong influence (p < 0.001). However, there was no significant interaction between rotation and complexity (p = 0.62), indicating that the effects of each factor on accuracy are independent and do not influence each other.

# Plotting for rotation technique
data.rotating.matched.accuracy_avg.long %>%
  group_by(rotationCondition) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(rotationCondition = case_when(
    rotationCondition == "oneHanded" ~ "One Handed",
    rotationCondition == "twoHanded" ~ "Two Handed",
    TRUE ~ as.character(rotationCondition))) %>%
  ggplot(aes(x = rotationCondition, y = mean_mean_accuracy, fill = rotationCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci), width = 0.2) +
  labs(
    title = "Mean Match Accuracy by Globe Rotating Techniques",
    x = "Globe Technique",
    y = "Mean Accuracy",
    fill = "Globe Technique"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank())

# Plotting for complexity factor
data.rotating.matched.accuracy_avg.long %>%
  group_by(complexity) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  ggplot(aes(x = complexity, y = mean_mean_accuracy, fill = complexity)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci), width = 0.2) +
  labs(
    title = "Mean Match Accuracy by globe rotation techniques and factors",
    x = "Globe Techniques",
    y = "Mean Accuracy",
    fill = "Complexity Factors"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank())

# Plotting for both rotation factors and techniques
data.rotating.matched.accuracy_avg.long %>%
  group_by(rotationCondition, complexity) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(rotationCondition = case_when(
    rotationCondition == "oneHanded" ~ "One Handed",
    rotationCondition == "twoHanded" ~ "Two Handed",
    TRUE ~ as.character(rotationCondition))) %>%
  ggplot(aes(x = rotationCondition, y = mean_mean_accuracy, fill = rotationCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci),
                width = 0.2) +
  facet_wrap(~ complexity) +
  labs(
    title = "Mean Match Accuracy by Globe Rotating Techniques and Complexity Factors",
    x = "rotation Condition",
    y = "Mean Accuracy",
    fill = "rotation Condition"
  ) +
  theme_minimal() +
    theme(
    axis.text.x = element_blank()
  )

# Boxplots for rotation techniques and condition

ggplot(data.rotating.matched.accuracy_avg.long, aes(x = rotationCondition, y = mean_accuracy)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  facet_wrap(~ complexity) + 
  labs(title = "Boxplots of Task Accuracy by Technique and Complexity",
       x = "Technique",
       y = "Match Accuracy") +
  theme_minimal()
```

##### Completion Time

###### Normality

```{r Rotation Task Study - Completion Time - Normality}

shapiro.test(data.rotating.time$Time)

hist(data.rotating.time$Time, breaks = 100,
     main = "Histogram of Rotation Gestures Task Completion Time", xlab = "Completion Time",
     col = "lightblue", xlim = c(0, 2))

plot(density(data.rotating.time$Time), 
     main = "Density Plot of Rotation Gestures Task Completion Time", xlab = "Completion Time",
     col = "blue", lwd = 2, xlim = c(0, 2))

```

###### Statistical Tests

```{r Rotation Task Study - Completion Time - Statistical Tests}

data.rotating.taskCompletion_avg.long <- data.rotating %>%
  group_by(UserID, rotationCondition, complexity, TaskID) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  group_by(UserID, rotationCondition, complexity) %>%
  summarise(
    avg_completion_time = mean(completion_time),
    .groups = "drop"
  )

data.rotating.taskCompletion_avg.art <- art(avg_completion_time ~ rotationCondition * complexity + (1|UserID), data = data.rotating.taskCompletion_avg.long)

anova(data.rotating.taskCompletion_avg.art)

	# •	rotationCondition: F(1, 33) = 8.44, p = 0.0065 (**) Statistically significant — rotation has a clear effect on completion time
	# •	complexity: F(1, 33) = 37.75, p < 0.0001 (***) Statistically significant — complexity strongly affects completion time
	# •	rotationCondition × complexity: F(1, 33) = 2.36, p = 0.1344 Not significant — no evidence of interaction between rotation and complexity

# Plotting for rotating techniques
data.rotating.taskCompletion_avg.long %>%
  group_by(rotationCondition) %>%
  summarise(
    mean_mean_time = mean(avg_completion_time, na.rm = TRUE),
    se = sd(avg_completion_time, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(rotationCondition = case_when(
    rotationCondition == "oneHanded" ~ "One Handed",
    rotationCondition == "twoHanded" ~ "Two Handed",
    TRUE ~ as.character(rotationCondition))) %>%
  ggplot(aes(x = rotationCondition, y = mean_mean_time, fill = rotationCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_time - ci, ymax = mean_mean_time + ci), width = 0.2) +
  labs(
    title = "Mean Match Accuracy by Globe Rotating Techniques",
    x = "Globe Rotating Techniques",
    y = "Average Completion Time",
    fill = "Globe Rotating Techniques"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank())

# Plotting for complexity factors
data.rotating.taskCompletion_avg.long %>%
  group_by(complexity) %>%
  summarise(
    mean_mean_time = mean(avg_completion_time, na.rm = TRUE),
    se = sd(avg_completion_time, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  ggplot(aes(x = complexity, y = mean_mean_time, fill = complexity)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_time - ci, ymax = mean_mean_time + ci), width = 0.2) +
  labs(
    title = "Mean Match Accuracy by Globe Complexity Factors",
    x = "Globe Complexity",
    y = "Average Completion Time",
    fill = "Globe Complexity"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank())

# Plotting for both rotation Factors and Technique
data.rotating.taskCompletion_avg.long %>%
  group_by(rotationCondition, complexity) %>%
  summarise(
    mean_mean_time = mean(avg_completion_time, na.rm = TRUE),
    se = sd(avg_completion_time, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(rotationCondition = case_when(
    rotationCondition == "oneHanded" ~ "One Handed",
    rotationCondition == "twoHanded" ~ "Two Handed",
    TRUE ~ as.character(rotationCondition))) %>%
  ggplot(aes(x = rotationCondition, y = mean_mean_time, fill = rotationCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_time - ci, ymax = mean_mean_time + ci),
                width = 0.2) +
  facet_wrap(~ complexity) +
  labs(
    title = "Mean Match Accuracy by Globe Rotating Techniques, Complexity Factors",
    x = "Globe rotating techniques",
    y = "Average Completion Time",
    fill = "Globe rotating techniques"
  ) +
  theme_minimal() +
    theme(
    axis.text.x = element_blank()
  )

# Boxplots for rotation techniques and complexity factors

ggplot(data.rotating.taskCompletion_avg.long, aes(x = rotationCondition, y = avg_completion_time)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  facet_wrap(~ complexity) +
  labs(title = "Boxplots of Task Completion Time by Technique and Complexity",
       x = "Technique",
       y = "Task Completion Time") +
  theme_minimal()

```


##### Subjective Measures

###### Physical and Mental Exertion

```{r Positioning - Physical and Mental Exertion}

data.rotating.combined_exertion <- data.rotating.paas %>%
  full_join(data.rotating.borg, by = c("UserID", "Technique")) %>%
  pivot_longer(
    cols = c(PAAS, BORGRPE),
    names_to = "Measure",
    values_to = "Score"
  ) %>%
  mutate(
    Measure = case_when(
      Measure == "PAAS" & Technique == "oneHanded" ~ "PAAS_OH",
      Measure == "PAAS" & Technique == "twoHanded" ~ "PAAS_TH",
      Measure == "BORGRPE" & Technique == "oneHanded" ~ "BORG_OH",
      Measure == "BORGRPE" & Technique == "twoHanded" ~ "BORG_TH",
      TRUE ~ Measure
    ),
    ExertionType = case_when(
      str_detect(Measure, "PAAS") ~ "Cognitive load",
      str_detect(Measure, "BORG") ~ "Physical exertion",
      TRUE ~ "Unknown"
    )
  ) %>%
  select(UserID, Technique, Measure, Score, ExertionType) %>%
  mutate(
    Technique = as.factor(Technique),
    ExertionType = as.factor(ExertionType)
  )

data.rotating.combined_exertion.art_anova <- art(Score ~ Technique * ExertionType + (1|UserID), data = data.rotating.combined_exertion)

anova(data.rotating.combined_exertion.art_anova)


# 	•	Main effect of rotationCondition: F(1, 33) = 4.28, p = 0.0466 This is statistically significant at the 0.05 level, indicating that rotating vs non-rotating globe conditions have a meaningful impact on participants’ perceived exertion scores (cognitive or physical).
#	  •	Main effect of ExertionType: F(1, 33) = 20.75, p < 0.001 This is highly significant,  showing a strong difference between cognitive load (PAAS) and physical exertion (BORG) scores, regardless of the globe rotation condition.
#  	•	Interaction effect (rotationCondition × ExertionType): F(1, 33) = 0.016, p = 0.8990 Not significant. Suggesting that the difference between cognitive and physical exertion is consistent across both rotation conditions. The type of exertion does not change depending on whether the globe was rotating or not.
# Both rotation condition and exertion type have independent effects on perceived exertion. Participants reported different exertion levels between rotating and non-rotating globes, and also between cognitive and physical demands. However, there is no interaction, meaning the relative difference between PAAS and BORG remains stable across rotation types.

ggplot(data.rotating.combined_exertion, aes(x = Technique, y = Score, fill = ExertionType)) +
  geom_boxplot(width = 0.1, position = position_dodge(0.8)) +
  labs(
    x = "Rotation Condition",
    y = "Score",
    title = "Distribution of Scores by Technique and Exertion Type"
  ) +
  theme_minimal()

data.rotating.combined_exertion %>%
  group_by(Technique, ExertionType) %>%
  summarise(
    mean_score = mean(Score),
    sd = sd(Score),
    n = n(),
    ci = qt(0.975, df = n - 1) * sd / sqrt(n),
    .groups = "drop"
  ) %>%
  ggplot(aes(x = Technique, y = mean_score, fill = ExertionType)) +
  geom_col(position = position_dodge(width = 0.7), width = 0.6) +
  geom_errorbar(aes(ymin = mean_score - ci, ymax = mean_score + ci),
                position = position_dodge(width = 0.7), width = 0.2) +
  labs(
    x = "Rotation Technique",
    y = "Mean Score (95% CI)",
    fill = "Exertion Type",
    title = "Mean Score by Position Condition and Exertion Type"
  ) +
  theme_minimal()

```

###### Preference

```{r Rotating - Preference}

data.rotating.qualitative %>%
  count(Rotation_preference) %>%
  mutate(
    percent = n / sum(n),
    ncount = paste0(n, "\n", percent_format()(percent))
  ) %>%
  ggplot(aes(x = "", y = n, fill = Rotation_preference)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = ncount), position = position_stack(vjust = 0.5), size = 4) +
  labs(
    title = "Distribution of Rotation Technique Preferences",
    fill = "Preference"
  ) +
  theme_void()

```


###### Comments


```{r Rotating - Comments}

data.rotating.qualitative %>%
  mutate(
    Rotation_preference = case_when(
      Rotation_preference == "oneHandedPreference" ~ "One-handed Rotation Gesture",
      Rotation_preference == "twoHandedPreference" ~ "Two-handed Rotation Gesture",
      Rotation_preference == "noPreference" ~ "No Preference",
      TRUE ~ Rotation_preference
    )
  ) %>%
  rename(
    "Participant ID" = UserID,
    "Rotating Preference" = Rotation_preference,
    "Rotating Feedback" = Rotation_feedback
  ) %>%
  kable(caption = "User Feedback Summary - Rotating", align = "c") %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = FALSE,
    position = "center"
  ) %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#f7f7f7") %>%
  scroll_box(width = "100%", height = "400px")

```

###### Summary

### Study: Scale

#### Scale Data Preparation

```{r Scale Data Preparation}

data.scale <- data %>%
  mutate(scaleCondition = if_else(moveGlobeWhileScaling, "movingGlobe", "nonMovingGlobe")) %>%
  select(-moveGlobeWhileScaling) %>%
  inner_join(demographic, by = "UserID") %>%
  inner_join(scale_MG, by = "UserID") %>%
    rename(
    PAAS_MG = Mentally_demanding,
    BORG_MG = Physically_demanding
  ) %>%
  mutate(
    PAAS_MG = as.numeric(str_extract(PAAS_MG, "\\d+(\\.\\d+)?")),
    BORG_MG = as.numeric(str_extract(BORG_MG, "\\d+(\\.\\d+)?"))
  ) %>%
  mutate(
    PAAS_MG = if_else(scaleCondition == "movingGlobe", PAAS_MG, NA_real_),
    BORG_MG = if_else(scaleCondition == "movingGlobe", BORG_MG, NA_real_)
  ) %>%
  inner_join(scale_NMG, by = "UserID") %>%
  rename(
    PAAS_NMG = Mentally_demanding,
    BORG_NMG = Physically_demanding
  ) %>%
  mutate(
    PAAS_NMG = as.numeric(str_extract(PAAS_NMG, "\\d+(\\.\\d+)?")),
    BORG_NMG = as.numeric(str_extract(BORG_NMG, "\\d+(\\.\\d+)?"))
  ) %>%
  mutate(
    PAAS_NMG = if_else(scaleCondition == "nonMovingGlobe", PAAS_NMG, NA_real_),
    BORG_NMG = if_else(scaleCondition == "nonMovingGlobe", BORG_NMG, NA_real_)
  ) %>%
  inner_join(scale_preference, by = "UserID") %>%
  rename(
    behaviour_preference = Scale_preference,
    behaviour_feedback = Scale_feedback
  ) %>%
  mutate(
    behaviour_preference = case_when(
    str_detect(behaviour_preference, "Maintain distance") ~ "maintainDistance",
    str_detect(behaviour_preference, "Maintain globe") ~ "maintainGlobe",
    str_detect(behaviour_preference, "no preference") ~ "noPreference",
    TRUE ~ "unknown"
  )) %>%
  filter(Type == "scaleTask") %>%
  select(UserID, TaskID, ActionID, scaleCondition, zoomDirection, Date, ActionStatus, main_scale_x,
  main_scale_y, main_scale_z, target_scale_x, target_scale_y, target_scale_z, match_accuracy_result, status,
  PAAS_MG, BORG_MG, PAAS_NMG, BORG_NMG, behaviour_preference, behaviour_feedback) %>%
  mutate(zoomDirection = as.factor(zoomDirection), 
         scaleCondition = as.factor(scaleCondition),
         status = as.factor(status),
         behaviour_preference = as.factor(behaviour_preference))

```

#### Scale Task Study

##### Accuracy

###### Normality

```{r Scale Task Study - Accuracy - Normality}

shapiro.test(data.scale.accuracy$Accuracy)

hist(data.scale.accuracy$Accuracy, breaks = 100,
     main = "Histogram of Scaling Gestures Accuracy", xlab = "Accuracy",
     col = "lightblue", xlim = c(0, 0.12))

plot(density(data.scale.accuracy$Accuracy), 
     main = "Density Plot of Scaling Gestures Accuracy", xlab = "Accuracy",
     col = "blue", lwd = 2, xlim = c(0, 0.15))

# Although the w value is close to 1, the p value is below 0.05 so we reject null hypothesis that the data is normally distributed
# So, we cannot use one way ANOVA, instead, we use Wilcoxon signed-rank test
```

###### Statistical tests 

```{r Scale Task Study - Accuracy - Statistical Tests}

data.scale.matched <- data.scale %>%
  filter(status == "Matched")

data.scale.matched.accuracy_avg.long <- data.scale.matched %>%
  group_by(UserID, scaleCondition, zoomDirection) %>%
  summarise(mean_accuracy = mean(match_accuracy_result, na.rm = TRUE), .groups = 'drop')

data.scale.matched.art <- art(mean_accuracy ~ scaleCondition * zoomDirection + (1|UserID), data = data.scale.matched.accuracy_avg.long)

anova(data.scale.matched.art)

# •	The main effect of scaleCondition on mean accuracy was not significant, F(1, 33) = 0.55, p = 0.464.
# •	The main effect of zoomDirection was also not significant, F(1, 33) = 0.51, p = 0.478.
# •	The interaction between scaleCondition and zoomDirection was not significant either, F(1, 33) = 0.95, p = 0.336.

# There were no statistically significant effects of either scale condition, zoom direction, or their interaction on mean accuracy. This suggests that participants’ accuracy was not influenced by how the globe was scaled or zoomed, nor by the combination of these two factors.

# Plotting for scale behaviours
data.scale.matched.accuracy_avg.long %>%
  group_by(scaleCondition) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(scaleCondition = case_when(
    scaleCondition == "movingGlobe" ~ "Moving Globe",
    scaleCondition == "nonMovingGlobe" ~ "Non Moving Globe",
    TRUE ~ as.character(scaleCondition))) %>%
  ggplot(aes(x = scaleCondition, y = mean_mean_accuracy, fill = scaleCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci), width = 0.2) +
  labs(
    title = "Mean Match Accuracy by Globe Behaviour",
    x = "Globe Behaviour",
    y = "Mean Accuracy",
    fill = "Globe Behaviour"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank())

# Plotting for direction conditions
data.scale.matched.accuracy_avg.long %>%
  group_by(zoomDirection) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  ggplot(aes(x = zoomDirection, y = mean_mean_accuracy, fill = zoomDirection)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci), width = 0.2) +
  labs(
    title = "Mean Match Accuracy by Globe Zoom Direction Factors",
    x = "Globe Zoom Direction",
    y = "Mean Accuracy",
    fill = "Globe Direction"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank())

# Plotting for both scale Conditions and Behaviours
data.scale.matched.accuracy_avg.long %>%
  group_by(scaleCondition, zoomDirection) %>%
  summarise(
    mean_mean_accuracy = mean(mean_accuracy, na.rm = TRUE),
    se = sd(mean_accuracy, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(scaleCondition = case_when(
    scaleCondition == "movingGlobe" ~ "Moving Globe",
    scaleCondition == "nonMovingGlobe" ~ "Non Moving Globe",
    TRUE ~ as.character(scaleCondition))) %>%
  ggplot(aes(x = scaleCondition, y = mean_mean_accuracy, fill = scaleCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_accuracy - ci, ymax = mean_mean_accuracy + ci),
                width = 0.2) +
  facet_wrap(~ zoomDirection) +
  labs(
    title = "Mean Match Accuracy by Globe Behaviour, and Zoom Direction Factors",
    x = "Globe scale Behaviour",
    y = "Mean Accuracy",
    fill = "Globe scale Behaviour"
  ) +
  theme_minimal() +
    theme(
    axis.text.x = element_blank()
  )

# Boxplots for globe behaviour and conditions

ggplot(data.scale.matched.accuracy_avg.long, aes(x = scaleCondition, y = mean_accuracy)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  facet_wrap(~ zoomDirection) + 
  labs(title = "Boxplots of Accuracy by Globe Movement Behaviour",
       x = "Behaviour",
       y = "Match Accuracy") +
  theme_minimal()
```

##### Completion Time

###### Normality

```{r Scale Task Study - Completion Time - Normality}

shapiro.test(data.scale.time$Time)

hist(data.scale.time$Time, breaks = 100,
     main = "Histogram of Scale Gestures Task Completion Time", xlab = "Completion Time",
     col = "lightblue", xlim = c(0, 0.8))

plot(density(data.scale.time$Time), 
     main = "Density Plot of Scale Gestures Task Completion Time", xlab = "Completion Time",
     col = "blue", lwd = 2, xlim = c(0, 0.8))

```

###### Statistical Tests

```{r Scale Task Study - Completion Time - Statistical Tests}

data.scale.taskCompletion_avg.long <- data.scale %>%
  group_by(UserID, scaleCondition, TaskID, zoomDirection) %>%
  summarise(
    completion_time = as.numeric(difftime(max(Date), min(Date), units = "mins")),
    .groups = "drop"
  ) %>%
  group_by(UserID, scaleCondition, zoomDirection) %>%
  summarise(
    avg_completion_time = mean(completion_time),
    .groups = "drop"
  ) 

data.scale.taskCompletion.art <- art(avg_completion_time ~ scaleCondition * zoomDirection + (1|UserID), data = data.scale.taskCompletion_avg.long)

anova(data.scale.matched.art)

# scaleCondition F-value 0.549 P-value 0.464 means not significant
# zoomDirection F-value 0.514 P-value 0.478 means Not significant
# scaleCondition:zoomDirection (Interaction) F-value 0.953 Not significant

# The analysis revealed no statistically significant effects of scaleCondition, zoomDirection, or their interaction on mean accuracy. All p-values are well above the common alpha level of 0.05, indicating that neither the type of scaling nor the zoom direction had a meaningful impact on participants’ accuracy. Additionally, the lack of a significant interaction suggests that the combined effect of scaling and zoom direction does not influence accuracy either.


# Plotting for scale behaviour
data.scale.taskCompletion_avg.long %>%
  group_by(scaleCondition) %>%
  summarise(
    mean_mean_time = mean(avg_completion_time, na.rm = TRUE),
    se = sd(avg_completion_time, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(scaleCondition = case_when(
    scaleCondition == "movingGlobe" ~ "Moving Globe",
    scaleCondition == "nonmovingGlobe" ~ "Non Moving Globe",
    TRUE ~ as.character(scaleCondition))) %>%
  ggplot(aes(x = scaleCondition, y = mean_mean_time, fill = scaleCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_time - ci, ymax = mean_mean_time + ci), width = 0.2) +
  labs(
    title = "Mean Match Accuracy by Globe Behaviour",
    x = "Globe Behaviour",
    y = "Average Completion Time",
    fill = "Globe Behaviour"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank())

# Plotting for distance factors
data.scale.taskCompletion_avg.long %>%
  group_by(zoomDirection) %>%
  summarise(
    mean_mean_time = mean(avg_completion_time, na.rm = TRUE),
    se = sd(avg_completion_time, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  ggplot(aes(x = zoomDirection, y = mean_mean_time, fill = zoomDirection)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_time - ci, ymax = mean_mean_time + ci), width = 0.2) +
  labs(
    title = "Mean Match Accuracy by Globe Distance Factors",
    x = "Globe Distance",
    y = "Average Completion Time",
    fill = "Globe Distance"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_blank())

# Plotting for both Position Factors and Technique
data.scale.taskCompletion_avg.long %>%
  group_by(scaleCondition, zoomDirection) %>%
  summarise(
    mean_mean_time = mean(avg_completion_time, na.rm = TRUE),
    se = sd(avg_completion_time, na.rm = TRUE) / sqrt(n()),
    ci = qt(0.975, df = n() - 1) * se,
    .groups = "drop"
  ) %>%
  mutate(scaleCondition = case_when(
    scaleCondition == "movingGlobe" ~ "Moving Globe",
    scaleCondition == "nonMovingGlobe" ~ "Non Moving Globe",
    TRUE ~ as.character(scaleCondition))) %>%
  ggplot(aes(x = scaleCondition, y = mean_mean_time, fill = scaleCondition)) +
  geom_col(width = 0.6) +
  geom_errorbar(aes(ymin = mean_mean_time - ci, ymax = mean_mean_time + ci),
                width = 0.2) +
  facet_wrap(~ zoomDirection) +
  labs(
    title = "Mean Match Accuracy by Globe Behaviour, and Zoom Direction Factors",
    x = "Globe Positioning Behaviour",
    y = "Average Completion Time",
    fill = "Globe Positioning Behaviour"
  ) +
  theme_minimal() +
    theme(
    axis.text.x = element_blank()
  )

# Boxplots for Task Completion Time and Zoom Direction Factors

ggplot(data.scale.taskCompletion_avg.long, aes(x = scaleCondition, y = avg_completion_time)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue") +
  geom_jitter(width = 0.1, size = 2, alpha = 0.7) +
  facet_wrap(~ zoomDirection) + 
  labs(title = "Boxplots of Task Completion Time by Globe's Behaviour and Zoom Direction Factors",
       x = "Behaviour",
       y = "Task Completion Time") +
  theme_minimal()
```


##### Subjective Measures

###### Physical and Mental Exertion

```{r Scale - Physical and Mental Exertion}

data.scale.combined_exertion <- data.scale.paas %>%
  full_join(data.scale.borg, by = c("UserID", "Technique")) %>%
  pivot_longer(
    cols = c(PAAS, BORGRPE),
    names_to = "Measure",
    values_to = "Score"
  ) %>%
  mutate(
    Measure = case_when(
      Measure == "PAAS" & Technique == "movingGlobe" ~ "PAAS_MG",
      Measure == "PAAS" & Technique == "nonMovingGlobe" ~ "PAAS_NMG",
      Measure == "BORGRPE" & Technique == "movingGlobe" ~ "BORG_MG",
      Measure == "BORGRPE" & Technique == "nonMovingGlobe" ~ "BORG_NMG",
      TRUE ~ Measure
    ),
    ExertionType = case_when(
      str_detect(Measure, "PAAS") ~ "Cognitive load",
      str_detect(Measure, "BORG") ~ "Physical exertion",
      TRUE ~ "Unknown"
    )
  ) %>%
  select(UserID, Technique, Measure, Score, ExertionType) %>%
  mutate(
    Technique = as.factor(Technique),
    ExertionType = as.factor(ExertionType)
  )

data.scale.combined_exertion.art_anova <- art(Score ~ Technique * ExertionType + (1|UserID), data = data.scale.combined_exertion)
anova(data.scale.combined_exertion.art_anova)

# 	•	Main effect of scaleCondition: F(1, 33) = 1.36, p = 0.2521 Not statistically significant. This suggests that the scaling condition (e.g. scaled vs not scaled globe) did not have a meaningful effect on exertion scores overall. 
#  	•	Main effect of ExertionType: F(1, 33) = 55.27, p < 0.001 → Highly significant. This shows a strong difference between cognitive load (PAAS) and physical exertion (BORG) scores, regardless of the scale condition.
# 	•	Interaction (scaleCondition × ExertionType): F(1, 33) = 0.084, p = 0.7735. This means the difference between PAAS and BORG scores does not vary depending on whether scaling was involved.
# Only the type of exertion (cognitive vs physical) had a significant impact on participant scores. The scale condition had no effect, nor did it change the relationship between exertion types. Participants consistently rated cognitive and physical exertion differently, but this pattern was stable across both scaled and non-scaled conditions.

ggplot(data.scale.combined_exertion, aes(x = Technique, y = Score, fill = ExertionType)) +
  geom_boxplot(width = 0.1, position = position_dodge(0.8)) +
  labs(
    x = "Scale Technique",
    y = "Score",
    title = "Distribution of Scores by Behaviour and Exertion Type"
  ) +
  theme_minimal()

data.scale.combined_exertion %>%
  group_by(Technique, ExertionType) %>%
  summarise(
    mean_score = mean(Score),
    sd = sd(Score),
    n = n(),
    ci = qt(0.975, df = n - 1) * sd / sqrt(n),
    .groups = "drop"
  ) %>%
  ggplot(aes(x = Technique, y = mean_score, fill = ExertionType)) +
  geom_col(position = position_dodge(width = 0.7), width = 0.6) +
  geom_errorbar(aes(ymin = mean_score - ci, ymax = mean_score + ci),
                position = position_dodge(width = 0.7), width = 0.2) +
  labs(
    x = "Scale Technique",
    y = "Mean Score (95% CI)",
    fill = "Exertion Type",
    title = "Mean Score by Position Condition and Exertion Type"
  ) +
  theme_minimal()

```

###### Preference

```{r Scale - Preference}

data.scale.qualitative %>%
  count(Scale_preference) %>%
  mutate(
    percent = n / sum(n),
    ncount = paste0(n, "\n", percent_format()(percent))
  ) %>%
  ggplot(aes(x = "", y = n, fill = Scale_preference)) +
  geom_col(width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = ncount), position = position_stack(vjust = 0.5), size = 4) +
  labs(
    title = "Distribution of Scale Behaviour Preferences",
    fill = "Preference"
  ) +
  theme_void()
```

###### Comments

```{r Scale - Comments}
data.scale.qualitative %>%
  mutate(
    Scale_preference = case_when(
      Scale_preference == "maintainDistance" ~ "Maintains distance",
      Scale_preference == "maintainGlobe" ~ "Maintains position",
      Scale_preference == "noPreference" ~ "No Preference",
      TRUE ~ Scale_preference
    )
  ) %>%
  rename(
    "Participant ID" = UserID,
    "Scale Preference" = Scale_preference,
    "Scale Feedback" = Scale_feedback
  ) %>%
  kable(caption = "User Feedback Summary - Scale", align = "c") %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = FALSE,
    position = "center"
  ) %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#f7f7f7") %>%
  scroll_box(width = "100%", height = "400px")

```


###### Summary


### Study: Combined Gesture Preference and Feedback

```{r Combined Gesture Preference and Feedback}

# Facet titles
interaction_labels <- c(
  Positioning_preference = "Positioning Preference",
  Rotation_preference = "Rotation Preference",
  Scale_preference = "Scale Preference"
)

data.combined.qualitative %>%
  mutate(
    Positioning_preference = case_when(
      Positioning_preference == "adaptiveOrientation" ~ "Adaptive Orientation",
      Positioning_preference == "staticOrientation" ~ "Static Orientation",
      Positioning_preference == "noPreference" ~ "No Preference",
      TRUE ~ as.character(Positioning_preference)
    ),
    Rotation_preference = case_when(
      Rotation_preference == "oneHandedPreference" ~ "One Handed Preference",
      Rotation_preference == "twoHandedPreference" ~ "Two Handed Preference",
      Rotation_preference == "noPreference" ~ "No Preference",
      TRUE ~ as.character(Rotation_preference)
    ),
    Scale_preference = case_when(
      Scale_preference == "maintainDistance" ~ "Maintains Distance",
      Scale_preference == "maintainGlobe" ~ "Maintains Position",
      Scale_preference == "noPreference" ~ "No Preference",
      TRUE ~ as.character(Scale_preference)
    )
  ) %>%
  pivot_longer(
    cols = c(Positioning_preference, Rotation_preference, Scale_preference),
    names_to = "Interaction_Type",
    values_to = "Preference"
  ) %>%
  ggplot(aes(x = Preference, fill = Preference)) +
  geom_bar(show.legend = FALSE) +
  facet_wrap(
    ~ Interaction_Type,
    scales = "free",
    labeller = labeller(Interaction_Type = interaction_labels)
  ) +
  scale_y_continuous(breaks = 1:10, limits = c(0, 10)) +
  labs(
    title = "User Preference Distribution by Interaction Type",
    x = "Preference",
    y = "Count"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 30, hjust = 1),
    strip.text = element_text(face = "bold")
  )

data.combined.qualitative %>%
  mutate(
    Positioning_preference = case_when(
      Positioning_preference == "adaptiveOrientation" ~ "Adaptive Orientation",
      Positioning_preference == "staticOrientation" ~ "Static Orientation",
      Positioning_preference == "noPreference" ~ "No Preference",
      TRUE ~ Positioning_preference
    ),
    Rotation_preference = case_when(
      Rotation_preference == "oneHandedPreference" ~ "One Handed Preference",
      Rotation_preference == "twoHandedPreference" ~ "Two Handed Preference",
      Rotation_preference == "noPreference" ~ "No Preference",
      TRUE ~ Scale_preference
    ),
    Scale_preference = case_when(
      Scale_preference == "maintainDistance" ~ "Maintains distance",
      Scale_preference == "maintainGlobe" ~ "Maintains position",
      Scale_preference == "noPreference" ~ "No Preference",
      TRUE ~ Scale_preference
    ),
  ) %>%
  rename(
    "Participant ID" = UserID,
    "Positioning Preference" = Positioning_preference,
    "Rotating Preference" = Rotation_preference,
    "Scale Preference" = Scale_preference,
    "Combined Feedback" = Combined_feedback
  ) %>%
  kable(caption = "User Feedback Summary - Scale", align = "c") %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = FALSE,
    position = "center"
  ) %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE, background = "#f7f7f7") %>%
  scroll_box(width = "100%", height = "400px")


```
